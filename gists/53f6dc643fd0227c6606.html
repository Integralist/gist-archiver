<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Golang Essentials</title>
<link rel="stylesheet" type="text/css" href="../assets/css/styles.css">
</head>
<body>
<div class="container">
<a href="../index.html" class="back-link">&laquo; Back to Index</a>
<h1 id="golang-essentials">Golang Essentials</h1>

<p><a href="https://gist.github.com/Integralist/53f6dc643fd0227c6606" target="_blank">View original Gist on GitHub</a></p>

<h2 id="golang-essentials-md">Golang Essentials.md</h2>

<ul>
<li><a href="#install">Install</a></li>
<li><a href="#shell-exports">Shell exports</a></li>
<li><a href="#directory-explanations">Directory explanations</a></li>
<li><a href="#automatic-imports">Automatic Imports</a></li>
<li><a href="#private-repo-access">Private repo access</a></li>
<li><a href="#guard-automatic-go-run">Guard (automatic go run)</a></li>
<li><a href="#godo">Godo</a></li>
<li><a href="#spurious">Spurious</a></li>
<li><a href="#aws-sdk-with-go">AWS SDK with Go (inc. some old possibly broken examples)</a></li>
<li><a href="#build-and-compilation">Build and Compilation</a></li>
<li><a href="#dependency-information-with-go-list">Dependency information with <code>go list</code></a></li>
<li><a href="#dependencies-with-godeps">Dependencies with godeps</a></li>
<li><a href="#dependencies-with-gb">Dependencies with gb</a></li>
<li><a href="#dependencies-with-glide">Dependencies with glide</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#logging">Logging</a></li>
<li><a href="#bits-bytes-runes">Bits, Bytes, Runes</a></li>
<li><a href="#code-examples">Code Examples</a>

<ul>
<li><a href="#init">Init</a></li>
<li><a href="#new-vs-make">New vs Make</a></li>
<li><a href="#custom-types">Custom Types</a></li>
<li><a href="#function-types">Function Types</a></li>
<li><a href="#struct-var-vs-type">Structure: Var vs Type</a></li>
<li><a href="#reference-vs-value">Reference vs Value</a></li>
<li><a href="#see-all-methods-of-a-type">See all methods of a &amp;lt;Type&amp;gt;</a></li>
<li><a href="#set-time">Set time</a></li>
<li><a href="#convert-struct-into-json">Convert Struct into JSON</a></li>
<li><a href="#extract-only-json-you-need">Extract only JSON you need</a></li>
<li><a href="#nested-json-handling">Nested JSON handling</a></li>
<li><a href="#pretty-printing-json-string">Pretty Printing JSON String</a></li>
<li><a href="#nested-yaml-handling">Nested YAML handling</a></li>
<li><a href="#unknown-yaml-structure">Unknown YAML Structure</a></li>
<li><a href="#sorting-structs">Sorting Structs</a></li>
<li><a href="#read-users-input">Read User Input</a></li>
<li><a href="#web-server">Web Server</a></li>
<li><a href="#middleware">Middleware</a></li>
<li><a href="#sessions">Sessions</a></li>
<li><a href="#http-requests-with-timeouts">HTTP Requests with Timeouts</a></li>
<li><a href="#s3-getobject">S3 GetObject</a></li>
<li><a href="#compile-time-variables">Compile time variables</a></li>
<li><a href="#tls-http-request">TLS HTTP Request</a></li>
<li><a href="#custom-http-request">Custom HTTP Request</a></li>
<li><a href="#http-get-web-page">HTTP GET Web Page</a></li>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#array-pointer">Array Pointer</a></li>
<li><a href="#type-assertion">Type Assertion</a></li>
<li><a href="#line-count">Line Count</a></li>
<li><a href="#measuring-time">Measuring time</a></li>
<li><a href="#reading-a-file-in-chunks">Reading a file in chunks</a></li>
<li><a href="#time-and-channels">Time and Channels</a></li>
<li><a href="#quit-a-channel">Quit a Channel</a></li>
<li><a href="#starting-and-stopping-things-with-channels">Starting and Stopping things with Channels</a></li>
<li><a href="#channel-pipelines">Channel Pipelines</a></li>
<li><a href="#templating">Templating</a></li>
<li><a href="#error-handling-with-context">Error handling with context</a></li>
<li><a href="#socket-programming-with-tcp-server">Socket programming with TCP server</a></li>
<li><a href="#comparing-maps">Comparing maps</a></li>
<li><a href="#embedded-structs">Embedded Structs</a></li>
<li><a href="#zip-file-contents">Zip File Contents</a></li>
<li><a href="https://gist.github.com/Integralist/0e277a517fee68153f93" target="_blank">OAuth</a></li>
<li><a href="#rpc">RPC</a></li>
<li><a href="#enumerator-iota">Enumerator IOTA</a></li>
<li><a href="#fizzbuzz">FizzBuzz</a></li>
<li><a href="#execute-shell-command">Execute Shell Command</a></li>
<li><a href="#new-instance-idiom">New Instance Idiom</a></li>
<li><a href="#mutating-values">Mutating Values</a></li>
<li><a href="#draining-connections">Draining Connections</a></li>
</ul></li>
</ul>

<h2 id="install">Install</h2>

<pre><code class="language-bash">brew install go
</code></pre>

<h2 id="shell-exports">Shell exports</h2>

<ul>
<li><code>export GOPATH=~/path/to/your/golang/projects</code></li>
<li><code>export PATH=~/path/to/your/golang/projects/bin:$PATH</code></li>
</ul>

<blockquote>
<p>Note: the latter item allows you to locally build and execute Go based binaries</p>
</blockquote>

<h2 id="directory-explanations">Directory explanations</h2>

<p>By default you store all your Golang projects within a single directory. This will be fixed in a future Go release as the developers recognise it can be problematic sometimes.</p>

<p>So within the <code>$GOPATH</code> directory workspace there should be three directories:</p>

<ul>
<li><code>src</code>: holds source code</li>
<li><code>pkg</code>: holds compiled bits</li>
<li><code>bin</code>: holds executables</li>
</ul>

<blockquote>
<p>Note: I very rarely even look at the <code>pkg</code> or <code>bin</code> directories</p>
</blockquote>

<p>But for now, make sure you have any new Go project you work on placed inside the following directory structure&hellip;</p>

<pre><code>└── src
    ├── github.com
    │   ├── &lt;your_username&gt;
    │   │   └── &lt;your_repo_name&gt;
</code></pre>

<h2 id="automatic-imports">Automatic Imports</h2>

<p><code>go get golang.org/x/tools/cmd/goimports</code></p>

<p>Now either run <code>goimports</code> from the shell OR use vim-go plugin with <code>:GoImports</code> for the buffer you&rsquo;re working with</p>

<h2 id="private-repo-access">Private repo access</h2>

<p><code>go get</code> uses https; so instead force it to use ssh:</p>

<pre><code class="language-bash">git config --global url.&quot;git@github.com:&quot;.insteadOf &quot;https://github.com/&quot;
</code></pre>

<blockquote>
<p>Note you can restrict it to a specific organisation as well:<br />
<code>git config --global url.&quot;git@github.com:foo/&quot;.insteadOf &quot;https://github.com/foo/&quot;</code></p>
</blockquote>

<p>So when you want a private repository: <code>git@github.com:foo/private.git</code></p>

<p>You can run:</p>

<pre><code class="language-bash">go get github.com/foo/private
</code></pre>

<h2 id="guard-automatic-go-run">Guard (automatic <code>go run</code>)</h2>

<p><strong>UPDATE</strong>: this isn&rsquo;t good practice. Instead use <a href="https://github.com/go-godo/godo" target="_blank">Godo</a> (see below for example)</p>

<p><del>Follow this guide (<a href="https://gist.github.com/Integralist/b675a263897680e02fbd" target="_blank">https://gist.github.com/Integralist/b675a263897680e02fbd</a>) for using Guard to get real-time notifications for when changes occur in your Go programming files, and automatically trigger <code>go run</code>.</del></p>

<h2 id="godo">Godo</h2>

<p>Example taken from my own project <a href="https://github.com/Integralist/Go-Requester" target="_blank">go-requester</a></p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;

	do &quot;gopkg.in/godo.v2&quot;
)

func tasks(p *do.Project) {
	if pwd, err := os.Getwd(); err == nil {
		do.Env = fmt.Sprintf(&quot;GOPATH=%s/vendor::$GOPATH&quot;, pwd)
	}

	p.Task(&quot;server&quot;, nil, func(c *do.Context) {
		c.Start(&quot;main.go ./config/page.yaml&quot;, do.M{&quot;$in&quot;: &quot;./&quot;})
	}).Src(&quot;**/*.go&quot;)
}

func main() {
	do.Godo(tasks)
}
</code></pre>

<h2 id="spurious">Spurious</h2>

<p>If you need <a href="https://github.com/spurious-io/spurious" target="_blank">Spurious</a> set-up then update the <code>aws.config</code> accordingly:</p>

<pre><code class="language-Go">_dyn := dynamodb.New(&amp;aws.Config{
    Region:     &quot;eu-west-1&quot;,
    DisableSSL: true,
    Endpoint:   &quot;dynamodb.spurious.localhost:32770&quot;, // change port number to appropriate value
})

_s3 := s3.New(&amp;aws.Config{
    Region:           &quot;eu-west-1&quot;,
    Endpoint:         &quot;s3.spurious.localhost:32769&quot;, // change port number to appropriate value
    DisableSSL:       true,
    S3ForcePathStyle: true,
})
</code></pre>

<blockquote>
<p>Note: remember to set the AWS environment variables in your shell so Dynamo can pick them up (all other spurious services are fine without them)</p>
</blockquote>

<pre><code class="language-bash">export AWS_ACCESS_KEY_ID=development_access; export AWS_SECRET_ACCESS_KEY=development_secret; go run application.go
</code></pre>

<p>To populate your Spurious set-up you can use Ruby like so: <a href="https://gist.github.com/Integralist/58b25f860773d8d2dd3f" target="_blank">https://gist.github.com/Integralist/58b25f860773d8d2dd3f</a></p>

<h2 id="aws-sdk-with-go">AWS SDK with Go</h2>

<h3 id="sts-assume-role">STS Assume Role</h3>

<p>Usage:</p>

<pre><code>&lt;binary_name&gt; &lt;aws_account_id&gt; &lt;aws_role&gt;
</code></pre>

<p>Code:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;os&quot;

	&quot;github.com/aws/aws-sdk-go/aws&quot;
	&quot;github.com/aws/aws-sdk-go/aws/session&quot;
	&quot;github.com/aws/aws-sdk-go/service/sts&quot;
)

var (
	accessKey = os.Getenv(&quot;AWS_ACCESS_KEY_ID&quot;)
	secretKey = os.Getenv(&quot;AWS_SECRET_ACCESS_KEY&quot;)
	region    = os.Getenv(&quot;AWS_REGION&quot;)
)

func main() {
	args := os.Args[1:]
	account := args[0]
	role := args[1]

	sess := session.New(
		&amp;aws.Config{
			Region: aws.String(region),
		},
	)

	svc := sts.New(sess)

	output, err := svc.AssumeRole(&amp;sts.AssumeRoleInput{
		RoleArn:         aws.String(fmt.Sprintf(&quot;arn:aws:iam::%s:role/%s&quot;, account, role)),
		RoleSessionName: aws.String(&quot;temp&quot;),
	})
	if err != nil {
		log.Fatalf(&quot;Unable to assume role: %v&quot;, err.Error())
	}

	os.Setenv(&quot;AWS_ACCESS_KEY_ID&quot;, aws.StringValue(output.Credentials.AccessKeyId))
	os.Setenv(&quot;AWS_SECRET_ACCESS_KEY&quot;, aws.StringValue(output.Credentials.SecretAccessKey))
	os.Setenv(&quot;AWS_SESSION_TOKEN&quot;, aws.StringValue(output.Credentials.SessionToken))

	fmt.Printf(&quot;AWS_ACCESS_KEY_ID: %s\n&quot;, os.Getenv(&quot;AWS_ACCESS_KEY_ID&quot;))
	fmt.Printf(&quot;AWS_SECRET_ACCESS_KEY: %s\n&quot;, os.Getenv(&quot;AWS_SECRET_ACCESS_KEY&quot;))
	fmt.Printf(&quot;AWS_SESSION_TOKEN: %s\n&quot;, os.Getenv(&quot;AWS_SESSION_TOKEN&quot;))
}
</code></pre>

<h3 id="create-sqs-queue">Create SQS queue</h3>

<p>Usage:</p>

<pre><code>go run local/create.go -queue &quot;producer&quot;
</code></pre>

<p>Code:</p>

<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;os&quot;
	&quot;os/exec&quot;

	&quot;github.com/aws/aws-sdk-go/aws&quot;
	&quot;github.com/aws/aws-sdk-go/aws/awserr&quot;
	&quot;github.com/aws/aws-sdk-go/aws/session&quot;
	&quot;github.com/aws/aws-sdk-go/service/sqs&quot;
)

type network []struct {
	Host     string
	HostPort string
}

type spurious struct {
	Sqs    network `json:&quot;spurious-sqs&quot;`
	S3     network `json:&quot;spurious-s3&quot;`
	Dynamo network `json:&quot;spurious-dynamo&quot;`
}

var (
	svc          *sqs.SQS
	queueName    string
	regionName   string
	endpointName string
	cmdOut       []byte
	err          error
	spur         spurious
)

var region = flag.String(&quot;region&quot;, &quot;eu-west-1&quot;, &quot;Name of region to create the resource within&quot;)
var queue = flag.String(&quot;queue&quot;, &quot;producer&quot;, &quot;Name of queue to be created&quot;)
var endpoint = flag.String(&quot;endpoint&quot;, &quot;&quot;, &quot;Spurious endpoint&quot;)

func init() {
	flag.Parse()

	queueName = *queue
	regionName = *region
	endpointName = *endpoint

	if endpointName == &quot;&quot; {
		cmdName := &quot;spurious&quot;
		cmdArgs := []string{&quot;ports&quot;, &quot;--json&quot;}
		if cmdOut, err = exec.Command(cmdName, cmdArgs...).Output(); err != nil {
			fmt.Fprintln(os.Stderr, &quot;There was an error running 'spurious ports --json' command: &quot;, err)
			os.Exit(1)
		}

		json.Unmarshal(cmdOut, &amp;spur)
		endpointName = spur.Sqs[0].Host + &quot;:&quot; + spur.Sqs[0].HostPort
	}

	svc = sqs.New(
		session.New(),
		&amp;aws.Config{
			Region:     aws.String(regionName),
			DisableSSL: aws.Bool(true),
			Endpoint:   aws.String(endpointName),
		})
}

func main() {
	params := &amp;sqs.CreateQueueInput{
		QueueName: aws.String(queueName),
	}

	resp, err := svc.CreateQueue(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Get error details
			log.Println(&quot;Error:&quot;, awsErr.Code(), awsErr.Message())

			// Prints out full error message, including original error if there was one.
			log.Println(&quot;Error:&quot;, awsErr.Error())

			// Get original error
			if origErr := awsErr.OrigErr(); origErr != nil {
				// operate on original error.
			}
		} else {
			fmt.Println(err.Error())
		}
	}

	fmt.Println(resp)
}
</code></pre>

<h3 id="possibly-broken-examples">Possibly Broken Examples</h3>

<p><strong>UPDATE</strong> the following code examples are now old and probably don&rsquo;t work any more</p>

<p>In the below code we use <code>go</code> blocks for parallelising &ldquo;copy&rdquo; requests to S3, which is thread-safe because we&rsquo;re not mutating any values. But we can&rsquo;t quite get away with that inside the <code>getS3Locations</code> function as we need to mutate a slice (and that&rsquo;s not thread-safe) so we then use an interesting pattern where by we use channels to synchronise the data after the parallelisation.</p>

<blockquote>
<p>Note: DynamoDB specifically is confusing.<br />
Also, for printing Structs use: <code>fmt.Printf(&quot;%+v&quot;, myStruct)</code> (ensures the keys are included)</p>
</blockquote>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;github.com/awslabs/aws-sdk-go/aws&quot;
	&quot;github.com/awslabs/aws-sdk-go/service/dynamodb&quot;
	&quot;github.com/awslabs/aws-sdk-go/service/s3&quot;
	&quot;os&quot;
	&quot;strings&quot;
	&quot;sync&quot;
)

func sequencerTableRecords(sequencer string) *dynamodb.ScanOutput {
	svc := dynamodb.New(&amp;aws.Config{
		Region: &quot;eu-west-1&quot;,
		DisableSSL: true,
		Endpoint:   &quot;dynamodb.spurious.localhost:32791&quot;,
	})

	params := &amp;dynamodb.ScanInput{
		TableName: aws.String(sequencer),
	}

	resp, err := svc.Scan(params)

	if awserr := aws.Error(err); awserr != nil {
		// A service error occurred.
		fmt.Println(&quot;Error:&quot;, awserr.Code, awserr.Message)
	} else if err != nil {
		// A non-service error occurred.
		panic(err)
	}

	return resp
}

func getComponentVersions(records *dynamodb.ScanOutput) map[string]string {
	components := make(map[string]string)

	for _, items := range records.Items {
		item := *items
		components[*item[&quot;key&quot;].S] = *item[&quot;value&quot;].N
	}

	return components
}

func getS3Locations(components map[string]string, s3Path string, lookup string) map[string]string {
	svc := dynamodb.New(&amp;aws.Config{
		Region: &quot;eu-west-1&quot;,
		DisableSSL: true,
		Endpoint:   &quot;dynamodb.spurious.localhost:32791&quot;,
	})

	collectedLocations := []*dynamodb.QueryOutput{}

	c := make(chan *dynamodb.QueryOutput, len(components))
	done := make(chan int, len(components))
	locations := make(map[string]string)

	// Parallelise retrieval of data from DynamoDB
	for componentKey, componentVersion := range components {
		go func(componentKey, componentVersion string) {
			params := &amp;dynamodb.QueryInput{
				TableName:      aws.String(lookup),
				ConsistentRead: aws.Boolean(true),
				Select:         aws.String(&quot;SPECIFIC_ATTRIBUTES&quot;),
				AttributesToGet: []*string{
					aws.String(&quot;component_key&quot;),
					aws.String(&quot;location&quot;),
				},
				KeyConditions: &amp;map[string]*dynamodb.Condition{
					&quot;component_key&quot;: &amp;dynamodb.Condition{
						ComparisonOperator: aws.String(&quot;EQ&quot;),
						AttributeValueList: []*dynamodb.AttributeValue{
							&amp;dynamodb.AttributeValue{
								S: aws.String(componentKey),
							},
						},
					},
					&quot;batch_version&quot;: &amp;dynamodb.Condition{
						ComparisonOperator: aws.String(&quot;EQ&quot;),
						AttributeValueList: []*dynamodb.AttributeValue{
							&amp;dynamodb.AttributeValue{
								N: aws.String(componentVersion),
							},
						},
					},
				},
			}

			resp, err := svc.Query(params)

			if awserr := aws.Error(err); awserr != nil {
				// A service error occurred.
				fmt.Println(&quot;Error:&quot;, awserr.Code, awserr.Message)
			} else if err != nil {
				// A non-service error occurred.
				panic(err)
			} else {
				c &lt;- resp
				done &lt;- 1
			}
		}(componentKey, componentVersion)
	}

	// Wait until all data is successfully collated from DynamoDB
	for i := len(components); i &gt; 0; {
		select {
		case item := &lt;-c:
			collectedLocations = append(collectedLocations, item)
		case &lt;-done:
			i--
		}
	}

	for _, items := range collectedLocations {
		item := *items
		ref := *item.Items[0]
		componentLocation := s3Path + *ref[&quot;location&quot;].S
		componentKey := extractComponentFromKey(*ref[&quot;component_key&quot;].S)

		locations[componentKey] = componentLocation
	}

	return locations
}

func extractComponentFromKey(componentKey string) string {
	return strings.Split(componentKey, &quot;/&quot;)[0]
}

func copyS3DataToNewLocation(event string, s3Bucket string, s3Locations map[string]string) {
	svc := s3.New(&amp;aws.Config{
		Region: &quot;eu-west-1&quot;,
		Endpoint:         &quot;s3.spurious.localhost:32790&quot;,
		DisableSSL:       true,
		S3ForcePathStyle: true,
	})

	var wg sync.WaitGroup

	for component, location := range s3Locations {
		destination := &quot;archive/&quot; + event + &quot;/&quot; + component

		wg.Add(1)

		go func(location, destination string) {
			defer wg.Done()

			// fmt.Println(s3Bucket)
			// fmt.Println(s3Bucket + &quot;/&quot; + location)
			// fmt.Println(destination)

			params := &amp;s3.CopyObjectInput{
				Bucket:     aws.String(s3Bucket),
				CopySource: aws.String(s3Bucket + &quot;/&quot; + location),
				Key:        aws.String(destination),
			}

			_, err := svc.CopyObject(params)

			if awserr := aws.Error(err); awserr != nil {
				// A service error occurred.
				fmt.Println(&quot;Error:&quot;, awserr.Code, awserr.Message)
			} else if err != nil {
				// A non-service error occurred.
				panic(err)
			}
		}(location, destination)
	}

	wg.Wait()
}

func main() {
	event := os.Args[1]
	s3Bucket := os.Args[2]
	s3Path := os.Args[3]
	sequencer := os.Args[4]
	lookup := os.Args[5]

	sequence_records := sequencerTableRecords(sequencer)
	components := getComponentVersions(sequence_records)
	s3Locations := getS3Locations(components, s3Path, lookup)

	copyS3DataToNewLocation(event, s3Bucket, s3Locations)
}
</code></pre>

<p>In above example there are API issues with DynamoDB - after about 6 requests a second the API errors. If you flatten out the requests so they are no longer running highly concurrently, then the speed of it slows down so badly that AWS Lambda (which is running the binary) times out. Meaning we need to do things differently&hellip; i.e. we need to request all S3 objects instead and partition/filter the unique values from that instead:</p>

<blockquote>
<p>Note: S3 objects are listed alphabetically</p>
</blockquote>

<pre><code class="language-go">func getS3ObjectSubset(bucket, source, marker string) *s3.ListObjectsOutput {
	svc := s3.New(&amp;aws.Config{
		Region: &quot;eu-west-1&quot;,
	})

	params := &amp;s3.ListObjectsInput{
		Bucket: aws.String(bucket),
		Prefix: aws.String(source),
		Marker: aws.String(marker),
	}

	resp, err := svc.ListObjects(params)

	if awserr := aws.Error(err); awserr != nil {
		fmt.Println(&quot;Error:&quot;, awserr.Code, awserr.Message)
	} else if err != nil {
		panic(err)
	}

	return resp
}

func main() {
	bucket := os.Args[1] // some-bucket
	source := os.Args[2] // some/object/path/to/prefix
	marker := &quot;&quot;         // means to start off from the very first object (overwritten)

	var resp *s3.ListObjectsOutput

	processing := true

	collectedObjects := []*s3.ListObjectsOutput{}

	for processing {
		resp = getS3ObjectSubset(bucket, source, marker)
		collectedObjects = append(collectedObjects, resp)
		marker = *resp.Contents[len(resp.Contents)-1].Key

		if *resp.IsTruncated == false {
			processing = false
		}
	}

	for _, s3SubSet := range collectedObjects {
		for _, items := range s3SubSet.Contents {
			fmt.Println(*items.Key)
		}
	}
}
</code></pre>

<h2 id="build-and-compilation">Build and Compilation</h2>

<h3 id="1-5">1.5+</h3>

<pre><code class="language-bash">GOOS=darwin GOARCH=386 go build foo.go
</code></pre>

<p>Here is a quick reference:</p>

<pre><code>$GOOS     $GOARCH
darwin    386      -- 32 bit MacOSX
darwin    amd64    -- 64 bit MacOSX
freebsd   386
freebsd   amd64
linux     386      -- 32 bit Linux
linux     amd64    -- 64 bit Linux
linux     arm      -- RISC Linux
netbsd    386
netbsd    amd64
openbsd   386
openbsd   amd64
plan9     386
windows   386      -- 32 bit Windows
windows   amd64    -- 64 bit Windows
</code></pre>

<h3 id="gox">Gox</h3>

<p>One time only commands:</p>

<ul>
<li><code>go get github.com/mitchellh/gox</code></li>
<li><code>gox -build-toolchain</code> (only necessary for 1.4.x and lower)</li>
</ul>

<p>Compilation (example is for AWS Lambda usage where only a single binary is needed):</p>

<ul>
<li><code>gox -osarch=&quot;linux/amd64&quot; -osarch=&quot;darwin/amd64&quot; -osarch=&quot;windows/amd64&quot; -output=&quot;foobar.{{.OS}}&quot;</code></li>
</ul>

<p>This will generate three files:</p>

<ol>
<li><code>foobar.darwin</code></li>
<li><code>foobar.linux</code></li>
<li><code>foobar.windows.exe</code></li>
</ol>

<h3 id="other-information">Other information</h3>

<p>Use the <code>-a</code> flag when running <code>go build</code>.</p>

<p>In short, if you dont&rsquo; use <code>go build -a -v .</code> then Go won&rsquo;t know if any packages are missing (you can find the gory details <a href="https://medium.com/@felixge/why-you-should-use-go-build-a-or-gb-c469157d5c1b#.jf5orcwrj" target="_blank">here</a>)</p>

<h2 id="dependency-information-with-go-list">Dependency information with <code>go list</code></h2>

<p>To see a list of dependencies for a given Go package you can utilise the <code>go list</code> command:</p>

<pre><code class="language-bash">go list -json strconv 
</code></pre>

<p>Which returns:</p>

<pre><code class="language-json">{
	&quot;Dir&quot;: &quot;/usr/local/Cellar/go/1.5.2/libexec/src/strconv&quot;,
	&quot;ImportPath&quot;: &quot;strconv&quot;,
	&quot;Name&quot;: &quot;strconv&quot;,
	&quot;Doc&quot;: &quot;Package strconv implements conversions to and from string representations of basic data types.&quot;,
	&quot;Target&quot;: &quot;/usr/local/Cellar/go/1.5.2/libexec/pkg/darwin_amd64/strconv.a&quot;,
	&quot;Goroot&quot;: true,
	&quot;Standard&quot;: true,
	&quot;Root&quot;: &quot;/usr/local/Cellar/go/1.5.2/libexec&quot;,
	&quot;GoFiles&quot;: [
		&quot;atob.go&quot;,
		&quot;atof.go&quot;,
		&quot;atoi.go&quot;,
		&quot;decimal.go&quot;,
		&quot;doc.go&quot;,
		&quot;extfloat.go&quot;,
		&quot;ftoa.go&quot;,
		&quot;isprint.go&quot;,
		&quot;itoa.go&quot;,
		&quot;quote.go&quot;
	],
	&quot;IgnoredGoFiles&quot;: [
		&quot;makeisprint.go&quot;
	],
	&quot;Imports&quot;: [
		&quot;errors&quot;,
		&quot;math&quot;,
		&quot;unicode/utf8&quot;
	],
	&quot;Deps&quot;: [
		&quot;errors&quot;,
		&quot;math&quot;,
		&quot;runtime&quot;,
		&quot;unicode/utf8&quot;,
		&quot;unsafe&quot;
	],
	&quot;TestGoFiles&quot;: [
		&quot;internal_test.go&quot;
	],
	&quot;XTestGoFiles&quot;: [
		&quot;atob_test.go&quot;,
		&quot;atof_test.go&quot;,
		&quot;atoi_test.go&quot;,
		&quot;decimal_test.go&quot;,
		&quot;example_test.go&quot;,
		&quot;fp_test.go&quot;,
		&quot;ftoa_test.go&quot;,
		&quot;itoa_test.go&quot;,
		&quot;quote_test.go&quot;,
		&quot;strconv_test.go&quot;
	],
	&quot;XTestImports&quot;: [
		&quot;bufio&quot;,
		&quot;bytes&quot;,
		&quot;errors&quot;,
		&quot;fmt&quot;,
		&quot;log&quot;,
		&quot;math&quot;,
		&quot;math/rand&quot;,
		&quot;os&quot;,
		&quot;reflect&quot;,
		&quot;runtime&quot;,
		&quot;strconv&quot;,
		&quot;strings&quot;,
		&quot;testing&quot;,
		&quot;time&quot;,
		&quot;unicode&quot;
	]
}
</code></pre>

<p>If you don&rsquo;t specify the <code>-json</code> flag then the default behaviour is to filter out the <code>ImportPath</code> field from the above JSON output. For example:</p>

<pre><code class="language-bash">go list strconv
</code></pre>

<p>Will return just the import path <code>strconv</code>.</p>

<blockquote>
<p>Documentation: <code>go help list | less</code></p>
</blockquote>

<p>You can also utilise Go&rsquo;s templating functionality on the returned JSON object by adding the <code>-f</code> flag:</p>

<pre><code class="language-bash">go list -f '{{join .Deps &quot; &quot;}}' strconv
</code></pre>

<p>Which filters out the <code>Deps</code> field, joins up all items it contains using whitespace and subsequently returns:</p>

<pre><code>errors math runtime unicode/utf8 unsafe
</code></pre>

<p>You can do more complex things such as:</p>

<pre><code class="language-bash">go list -f '{{.ImportPath}} -&gt; {{join .Imports &quot; &quot;}}' compress/...
</code></pre>

<p>Which will return something like:</p>

<pre><code>compress/bzip2 -&gt; bufio io sort
compress/flate -&gt; bufio fmt io math sort strconv
compress/gzip -&gt; bufio compress/flate errors fmt hash hash/crc32 io time
compress/lzw -&gt; bufio errors fmt io
compress/zlib -&gt; bufio compress/flate errors fmt hash hash/adler32 io
</code></pre>

<h2 id="dependencies-with-godeps">Dependencies with godeps</h2>

<p>When running <code>go get &lt;dependency&gt;</code> locally, Go will stick the dependency in the folder defined by your <code>$GOPATH</code> variable. So when you build your code into a binary using <code>go build &lt;script&gt;</code> it&rsquo;ll bake the dependencies into the binary (i.e. the binary is statically linked).</p>

<p>But if someone pulls down your repo and tries to do a build they&rsquo;ll need to have a network connection to pull down the dependencies, as their <code>$GOPATH</code> might not have those dependencies yet (unless the user manually executes <code>go get</code> for each dependency required). Also the dependencies they subsequently pull down could be a more recent (and untested version) of each dependency.</p>

<p>So to make this situation better we can use <a href="http://godoc.org/github.com/tools/godep" target="_blank">http://godoc.org/github.com/tools/godep</a> (<a href="https://github.com/tools/godep" target="_blank">https://github.com/tools/godep</a>) which sticks all your dependencies within a <code>Godeps</code> folder inside your project directory. You can then use <code>godep save -r ./...</code> to automatically update all your references to point to that local folder.</p>

<blockquote>
<p>Note: you might need to remove the <code>Godeps</code> folder and run <code>go get</code> if you get strange conflicts. The <code>./...</code> means to target all <code>.go</code> files</p>
</blockquote>

<p>This way users who clone your repo don&rsquo;t need an internet connection to pull the dependencies, as they already have them. But also they&rsquo;ll have the correct versions of the dependencies. This acts like a <code>Gemfile.lock</code> as you would typically find in the Ruby world.</p>

<pre><code class="language-bash">find . -name '*.go' -exec \
sed -i '' 's/github\.com\/bbc\/mozart\-config\-api\/src\/Godeps\/_workspace\/src\///' {} \;
</code></pre>

<h2 id="dependencies-with-gb">Dependencies with gb</h2>

<pre><code class="language-bash">go get -u github.com/constabulary/gb/...
gb vendor fetch &lt;pkg&gt;
gb build all
</code></pre>

<p>You&rsquo;ll need the following structure:</p>

<pre><code class="language-bash">├── src
│   ├── foo
│   │   └── main.go
└── vendor
    ├── manifest
    └── src
</code></pre>

<p>The <code>vendor</code> directory is auto-generated by the <code>gb vendor fetch &lt;pkg&gt;</code> command.</p>

<h2 id="dependencies-with-glide">Dependencies with glide</h2>

<p>This is now my preferred dependency management tool, as it works just like existing tools in other languages (e.g. Ruby&rsquo;s Bundler or Node&rsquo;s NPM) and so consistency is a plus.</p>

<p>It also provides the ability (like gb) to not commit dependencies but have specific versions vendored when running a simple command.</p>

<pre><code class="language-bash">go get github.com/Masterminds/glide
export GO15VENDOREXPERIMENT=1       # or use 1.6
glide init                          # generates glide.yaml
glide install                       # installs from lock file (creates it if not found)
glide update                        # updates dependencies and updates lock file
glide list                          # shows vendored deps
go test $(glide novendor)           # test only your package (not vendored packages)
</code></pre>

<blockquote>
<p>Note: to add a new dependency <code>glide get &lt;pkg_name&gt;</code></p>
</blockquote>

<h2 id="documentation">Documentation</h2>

<p><code>Godoc</code> is the original implementation for viewing documentation. Previous to <code>Godoc</code> there was <code>go doc</code>, but that was removed and then added <em>back</em> with totally different functionality.</p>

<p>The syntax structure for <code>go doc</code> is as follows:</p>

<pre><code>go doc &lt;pkg&gt;
go doc &lt;sym&gt;[.&lt;method&gt;]
go doc [&lt;pkg&gt;].&lt;sym&gt;[.&lt;method&gt;]
</code></pre>

<p>Here are some examples of using <code>go doc</code>:</p>

<pre><code>go doc json # same as go doc encoding/json
go doc json.Number
go doc json.Number.Float64
</code></pre>

<p>Here is the same but using <code>godoc</code> (where the syntax structure is <code>godoc &lt;pkg&gt; &lt;symbol&gt;</code>):</p>

<pre><code>godoc encoding/json # unlike &quot;go doc json&quot;, &quot;godoc json&quot; doesn't work as it's not a fully qualified path
godoc encoding/json Number
godoc -src builtin make | less
</code></pre>

<blockquote>
<p>Unlike with <code>go doc</code>, <code>godoc</code> doesn&rsquo;t allow filtering by <code>&lt;method&gt;</code><br />
It only goes as far as <code>&lt;pkg&gt; &lt;symbol&gt;</code></p>

<p>You can use <code>&lt;pkg&gt; &lt;symbol&gt; &lt;method&gt;</code><br />
and the method will be included in the results<br />
but you&rsquo;ll need to search for the method manually<br />
<code>godoc -src net/http Request ParseForm | less</code><br />
here is a similar result using <code>go doc</code><br />
<code>go doc http.Request.ParseForm | less</code></p>
</blockquote>

<p>The purpose of <code>go doc</code> was to provide a simplistic cli documentation viewer, where as <code>Godoc</code> has many more features available.</p>

<p>The <code>go doc</code> command also works not only with Go&rsquo;s own library&rsquo;s but your own custom packages as well.</p>

<p>There are some differences in what is returned though between <code>godoc</code> and <code>go doc</code> (mainly the latter is more succinct/compact so you can find the functions/types you&rsquo;re after and then you can expand into those once you&rsquo;ve found them; <code>godoc</code> is harder to sift through on the command line)&hellip;</p>

<h3 id="godoc-encoding-json-encoder"><code>godoc encoding/json Encoder</code></h3>

<pre><code>type Encoder struct {
    // contains filtered or unexported fields
}
    An Encoder writes JSON objects to an output stream.

func NewEncoder(w io.Writer) *Encoder
    NewEncoder returns a new encoder that writes to w.

func (enc *Encoder) Encode(v interface{}) error
    Encode writes the JSON encoding of v to the stream, followed by a
    newline character.

    See the documentation for Marshal for details about the conversion of Go
    values to JSON.
</code></pre>

<h3 id="go-doc-encoding-json-encoder"><code>go doc encoding/json Encoder</code></h3>

<pre><code>type Encoder struct {
        // Has unexported fields.
}

    An Encoder writes JSON objects to an output stream.

func NewEncoder(w io.Writer) *Encoder
func (enc *Encoder) Encode(v interface{}) error
</code></pre>

<blockquote>
<p>Notice the functions don&rsquo;t have their documentation notes printed with <code>go doc</code></p>
</blockquote>

<p>One other thing <code>godoc</code> has over <code>go doc</code> is the ability to view the source code using the <code>-src</code> flag:</p>

<pre><code>godoc -src builtin make | less
</code></pre>

<p>The <code>godoc</code> tool also has a full browser documentation suite available and allows you to generate HTML documentation for your project&hellip;</p>

<h3 id="full-browser-documentation">Full Browser Documentation</h3>

<p>Start a local documentation server and allow indexing (which takes a few minutes; you have to just keep trying the search until it&rsquo;s done)</p>

<pre><code>godoc -http ':6060' -index
</code></pre>

<p>You can then open a new terminal pane and search via cli if you prefer (rather than open up a browser to <a href="http://localhost:6060/" target="_blank">http://localhost:6060/</a>)</p>

<pre><code>godoc -q tls | less
</code></pre>

<p>You can also have the playground available if you need it in the browser, but it does require an internet connection to compile:</p>

<pre><code>godoc -http ':6060' -play
</code></pre>

<h2 id="testing">Testing</h2>

<blockquote>
<p>Note: see also <a href="https://gist.github.com/Integralist/cf76668bc46d75058ab5f566d96ce74a" target="_blank">examples here</a></p>
</blockquote>

<p>Test files are placed in the same directory as the file/package being tested. The convention is to use the same file name but suffix it with <code>_test</code>. So <code>foo.go</code> would have another file next to it called <code>foo_test.go</code>.</p>

<p>Run the tests: <code>go test -v ./...</code></p>

<p>You can also run a specific test like so: <code>go test -v command/config_test.go command/config.go</code></p>

<blockquote>
<p>Note: remember that your test file should have the same package name as your code being tested. This means the test file will have access to all the public functions and variables of that package (and so subsequently it&rsquo;ll have access to the code being tested)</p>
</blockquote>

<p>Here&rsquo;s our program:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type FooIO interface {
	Read() string
}

type Foo struct{}

func (f *Foo) Read() string {
	return &quot;We READ something from disk&quot;
}

func Stuff(f FooIO) string {
	return f.Read()
}

func main() {
	foo := &amp;Foo{}
	contents := Stuff(foo)
	fmt.Println(contents)
}
</code></pre>

<p>Here&rsquo;s our test:</p>

<pre><code class="language-go">package main

import (
	&quot;testing&quot;

	&quot;github.com/stretchr/testify/assert&quot;
)

type FakeFoo struct{}

func (s *FakeFoo) Read() string {
	return &quot;We 'pretend' to READ something from disk&quot;
}

func TestSomething(t *testing.T) {
	assert := assert.New(t)

	foo := &amp;FakeFoo{}
	contents := Stuff(foo)

	assert.Equal(contents, &quot;We 'pretend' to READ something from disk&quot;)
}
</code></pre>

<h3 id="test-examples">Test Examples</h3>

<p>Faking HTTP and WebServers can be a bit tricky:</p>

<pre><code class="language-go">package requester

import (
	&quot;bytes&quot;
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;net/http/httptest&quot;
	&quot;os&quot;
	&quot;strconv&quot;
	&quot;testing&quot;
	&quot;time&quot;

	&quot;github.com/bbc/mozart-requester/src/aggregator&quot;
	&quot;github.com/julienschmidt/httprouter&quot;
)

func TestSuccessResponse(t *testing.T) {
	upstream := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
		fmt.Fprintln(w, `{&quot;head&quot;:[ &quot;foo&quot; ],&quot;bodyInline&quot;:&quot;bar&quot;,&quot;bodyLast&quot;:[ &quot;baz&quot; ]}`)
	}))
	defer upstream.Close()

	router := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		Process(w, r, httprouter.Params{})
	}))
	defer router.Close()

	var config = []byte(fmt.Sprintf(`{
		&quot;components&quot;:[
			{&quot;id&quot;:&quot;foo&quot;,&quot;endpoint&quot;:&quot;%s&quot;,&quot;must_succeed&quot;:true},
			{&quot;id&quot;:&quot;bar&quot;,&quot;endpoint&quot;:&quot;%s&quot;,&quot;must_succeed&quot;:true}
		]
	}`, upstream.URL, upstream.URL))

	req, err := http.NewRequest(&quot;POST&quot;, router.URL, bytes.NewBuffer(config))

	client := &amp;http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}

	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)

	var result aggregator.Result
	json.Unmarshal(body, &amp;result)

	expectedStatus := &quot;success&quot;
	if result.Summary != expectedStatus {
		t.Errorf(&quot;The response:\n '%s'\ndidn't match the expectation:\n '%s'&quot;, result.Summary, expectedStatus)
	}

	expectedLength := 2
	if len(result.Components) != expectedLength {
		t.Errorf(&quot;The response:\n '%d'\ndidn't match the expectation:\n '%d'&quot;, len(result.Components), expectedLength)
	}
}

func TestFailureResponse(t *testing.T) {
	healthyUpstream := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
		fmt.Fprintln(w, `{&quot;head&quot;:[ &quot;foo&quot; ],&quot;bodyInline&quot;:&quot;bar&quot;,&quot;bodyLast&quot;:[ &quot;baz&quot; ]}`)
	}))
	defer healthyUpstream.Close()

	failingUpstream := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set(&quot;Content-Type&quot;, &quot;text/plain; charset=utf-8&quot;)
		w.WriteHeader(http.StatusNotFound)
		fmt.Fprintln(w, &quot;404 page not found&quot;)
	}))
	defer failingUpstream.Close()

	router := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		Process(w, r, httprouter.Params{})
	}))
	defer router.Close()

	var config = []byte(fmt.Sprintf(`{
		&quot;components&quot;:[
			{&quot;id&quot;:&quot;foo&quot;,&quot;endpoint&quot;:&quot;%s&quot;,&quot;must_succeed&quot;:true},
			{&quot;id&quot;:&quot;bar&quot;,&quot;endpoint&quot;:&quot;%s&quot;,&quot;must_succeed&quot;:true}
		]
	}`, healthyUpstream.URL, failingUpstream.URL))

	req, err := http.NewRequest(&quot;POST&quot;, router.URL, bytes.NewBuffer(config))

	client := &amp;http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}

	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)

	var result aggregator.Result
	json.Unmarshal(body, &amp;result)

	expectedSummary := &quot;failure&quot;
	if result.Summary != expectedSummary {
		t.Errorf(&quot;The response:\n '%s'\ndidn't match the expectation:\n '%s'&quot;, result.Summary, expectedSummary)
	}

	expectedLength := 2
	if len(result.Components) != expectedLength {
		t.Errorf(&quot;The response length:\n '%d'\ndidn't match the expectation:\n '%d'&quot;, len(result.Components), expectedLength)
	}

	expectedStatus := []int{}
	for _, value := range result.Components {
		if value.Status == 404 {
			expectedStatus = append(expectedStatus, value.Status)
		}
	}
	if len(expectedStatus) &lt; 1 || len(expectedStatus) &gt; 1 {
		t.Errorf(&quot;The response length:\n '%d'\ndidn't match the expectation:\n '%d'&quot;, len(expectedStatus), 1)
	}
}

func TestSlowResponse(t *testing.T) {
	healthyUpstream := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
		fmt.Fprintln(w, `{&quot;head&quot;:[ &quot;foo&quot; ],&quot;bodyInline&quot;:&quot;bar&quot;,&quot;bodyLast&quot;:[ &quot;baz&quot; ]}`)
	}))
	defer healthyUpstream.Close()

	slowUpstream := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		timeout, err := strconv.Atoi(os.Getenv(&quot;COMPONENT_TIMEOUT&quot;))
		if err != nil {
			t.Errorf(&quot;COMPONENT_TIMEOUT: %s&quot;, err.Error())
		}
		time.Sleep(time.Duration(timeout) * time.Millisecond)
		w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
		fmt.Fprintln(w, `{&quot;head&quot;:[ &quot;foo&quot; ],&quot;bodyInline&quot;:&quot;bar&quot;,&quot;bodyLast&quot;:[ &quot;baz&quot; ]}`)
	}))
	defer slowUpstream.Close()

	router := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		Process(w, r, httprouter.Params{})
	}))
	defer router.Close()

	var config = []byte(fmt.Sprintf(`{
		&quot;components&quot;:[
			{&quot;id&quot;:&quot;foo&quot;,&quot;endpoint&quot;:&quot;%s&quot;,&quot;must_succeed&quot;:true},
			{&quot;id&quot;:&quot;bar&quot;,&quot;endpoint&quot;:&quot;%s&quot;,&quot;must_succeed&quot;:true}
		]
	}`, healthyUpstream.URL, slowUpstream.URL))

	req, err := http.NewRequest(&quot;POST&quot;, router.URL, bytes.NewBuffer(config))

	client := &amp;http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}

	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)

	var result aggregator.Result
	json.Unmarshal(body, &amp;result)

	expectedStatus := 408
	for _, value := range result.Components {
		if value.ID == &quot;bar&quot; &amp;&amp; value.Status != expectedStatus {
			t.Errorf(&quot;The response:\n '%d'\ndidn't match the expectation:\n '%d'&quot;, value.Status, expectedStatus)
		}
	}

	expectedSummary := &quot;failure&quot;
	if result.Summary != expectedSummary {
		t.Errorf(&quot;The response:\n '%s'\ndidn't match the expectation:\n '%s'&quot;, result.Summary, expectedSummary)
	}
}
</code></pre>

<p>I typically run my tests using Make, but it ultimately looks like this:</p>

<pre><code>pushd src &amp;&amp; APP_ENV=test COMPONENT_TIMEOUT=100 go test -v $(glide novendor) &amp;&amp; popd
</code></pre>

<p>Here&rsquo;s another example of a test needing to fake things:</p>

<pre><code class="language-go">package retriever

import (
	&quot;bytes&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;strings&quot;
	&quot;testing&quot;

	&quot;github.com/PuerkitoBio/goquery&quot;
)

const href = &quot;http://bar.com/&quot;
const url = &quot;http://foo.com/&quot;

var body string

func fakeNewDocument(url string) (*goquery.Document, error) {
	body = strings.Replace(body, &quot;{}&quot;, href, 1)

	resp := &amp;http.Response{
		Status:        &quot;200 OK&quot;,
		StatusCode:    200,
		Proto:         &quot;HTTP/1.0&quot;,
		ProtoMajor:    1,
		ProtoMinor:    0,
		Body:          ioutil.NopCloser(bytes.NewBufferString(body)),
		ContentLength: int64(len(body)),
		Request:       &amp;http.Request{},
	}

	return goquery.NewDocumentFromResponse(resp)
}

func TestRetrieveReturnValue(t *testing.T) {
	// {} interpolated with constant's value
	body = `
		&lt;html&gt;
			&lt;body&gt;
				&lt;div class=&quot;productInfo&quot;&gt;
					&lt;a href=&quot;{}&quot;&gt;Bar&lt;/a&gt;
				&lt;/div&gt;
			&lt;/body&gt;
		&lt;html&gt;
	`
	coll, _ := Retrieve(url, fakeNewDocument)

	if response := coll[0]; response != href {
		t.Errorf(&quot;The response:\n '%s'\ndidn't match the expectation:\n '%s'&quot;, response, href)
	}
}

func TestRetrieveMissingAttributeReturnsEmptySlice(t *testing.T) {
	// href attribute is missing from anchor element
	body = `
		&lt;html&gt;
			&lt;body&gt;
				&lt;div class=&quot;productInfo&quot;&gt;
					&lt;a&gt;Bar&lt;/a&gt;
				&lt;/div&gt;
			&lt;/body&gt;
		&lt;html&gt;
	`
	coll, _ := Retrieve(url, fakeNewDocument)

	if response := coll; len(response) &gt; 0 {
		t.Errorf(&quot;The response:\n '%s'\ndidn't match the expectation:\n '%s'&quot;, response, &quot;[http://bar.com/]&quot;)
	}
}
</code></pre>

<p>And&hellip;</p>

<pre><code class="language-go">package scraper

import &quot;testing&quot;

func TestScrapeResults(t *testing.T) {
	getItem = func(url string) {
		defer wg.Done()

		ch &lt;- Item{
			&quot;FooTitle&quot;,
			&quot;FooSize&quot;,
			&quot;10.00&quot;,
			&quot;FooDescription&quot;,
		}
	}

	urls := []string{
		&quot;http://foo.com/&quot;,
		&quot;http://bar.com/&quot;,
		&quot;http://baz.com/&quot;,
	}

	result := Scrape(urls)
	first := result.Items[0]

	var suite = []struct {
		response string
		expected string
	}{
		{first.Title, &quot;FooTitle&quot;},
		{first.Size, &quot;FooSize&quot;},
		{first.UnitPrice, &quot;10.00&quot;},
		{first.Description, &quot;FooDescription&quot;},
		{result.Total, &quot;30.00&quot;},
	}

	for _, v := range suite {
		if v.response != v.expected {
			err(v.response, v.expected, t)
		}
	}
}

func err(response, expected string, t *testing.T) {
	t.Errorf(&quot;The response:\n '%s'\ndidn't match the expectation:\n '%s'&quot;, response, expected)
}
</code></pre>

<h2 id="logging">Logging</h2>

<p>Using the standard Logger:</p>

<pre><code class="language-go">info := log.New(os.Stdout, &quot;STUFF: &quot;, log.Ldate|log.Ltime|log.Lshortfile)
info.Println(&quot;Starting up!!!&quot;)

f, e := os.Create(&quot;test.log&quot;)
if e != nil {
	log.Fatal(&quot;Failed to create log file&quot;)
}

logfile := log.New(f, &quot;STUFF: &quot;, log.Ldate|log.Ltime|log.Lshortfile)
logfile.Println(&quot;Starting up!!!&quot;)
</code></pre>

<p>Using Logrus:</p>

<pre><code class="language-go">package main

import (
	&quot;os&quot;

	log &quot;github.com/Sirupsen/logrus&quot;
)

func main() {
	// Standard stdout ASCII logging
	log.WithFields(log.Fields{
		&quot;animal&quot;: &quot;walrus&quot;,
	}).Info(&quot;A walrus appears&quot;)

	// JSON style structured logging
	log.SetFormatter(&amp;log.JSONFormatter{})
	f, e := os.Create(&quot;logs&quot;)
	if e != nil {
		log.Fatal(&quot;Failed to create log file&quot;)
	}
	log.SetOutput(f)
	log.WithFields(log.Fields{
		&quot;animal&quot;: &quot;walrus&quot;,
		&quot;size&quot;:   10,
	}).Info(&quot;A group of walrus emerges from the ocean&quot;)
	/*
			{
				&quot;animal&quot;: &quot;walrus&quot;,
				&quot;level&quot;: &quot;info&quot;,
				&quot;msg&quot;: &quot;A group of walrus emerges from the ocean&quot;,
		    &quot;size&quot;: 10,
				&quot;time&quot;: &quot;2015-12-22T13:58:46Z&quot;
			}
	*/
}
</code></pre>

<h2 id="bits-bytes-runes">Bits, Bytes, Runes</h2>

<p><a href="https://pythonconquerstheuniverse.wordpress.com/2010/05/30/unicode-beginners-introduction-for-dummies-made-simple/" target="_blank">https://pythonconquerstheuniverse.wordpress.com/2010/05/30/unicode-beginners-introduction-for-dummies-made-simple/</a></p>

<p>A Unicode &ldquo;code point&rdquo; (e.g. <code>0021</code> which is equal to <code>!</code>) is known in Go as a &ldquo;Rune&rdquo;.</p>

<blockquote>
<p>Note: a Rune is actually a synonym for Go&rsquo;s <code>int32</code> type</p>
</blockquote>

<p>A Unicode &ldquo;code point&rdquo; is made up of a single byte.</p>

<p>Computers think in 8-bit bytes (i.e. a single byte is 8 bits).</p>

<p>With 8 bits you can make 256 different bit combinations. But Unicode has way more than 256 characters (it holds code points/characters for every language in the world, so yes a <em>lot</em> more than 256).</p>

<ul>
<li>1 bytes = 08 bits</li>
<li>2 bytes = 16 bits</li>
<li>3 bytes = 24 bits</li>
<li>4 bytes = 32 bits</li>
</ul>

<p>We could represent a Unicode &ldquo;code point&rdquo; with a single Rune (<code>int32</code>) but not all code points require a full 32 bits and so you&rsquo;d be wasting lots of space. For example, ASCII only requires 8 bits (or 1 byte) per character.</p>

<p>UTF-8 is a solution to this problem. It uses 8-bit encoding, but one of the bits will be a pointer to another location to continue the bit sequence so the program can identify the overall character being encoded. This allows all Unicode code points to be encoded in 1 to 4 bytes but without the need for all the storage required of a 32 bit set-up.</p>

<p>So as you can now see, UTF-8 is able to use multiple bytes (up to 4) to represent a single Unicode code point.</p>

<p>For example, <code>[E4 B8 96]</code> are three separate bytes that make up a single Chinese character.</p>

<p>A string is made up of individual bytes, but not every character in the string is necessarily mapped to a single byte (also ASCII charters like <code>\n</code> and <code>\t</code> are considered a byte each)</p>

<blockquote>
<p>Note: a Rune can consist of multiple bytes (so it&rsquo;s not <em>exactly</em> identical to a Unicode &ldquo;code point&rdquo;)</p>
</blockquote>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;unicode/utf8&quot;
)

func main() {
	hello := &quot;您好 world&quot;

	fmt.Printf(&quot;hex digits: % x\n&quot;, hello) // hex digits: e6 82 a8 e5 a5 bd 20 77 6f 72 6c 64

	// e6 82 a8 e5 a5 bd == 您好
	// 20                == &lt;white space character&gt;
	// 77 6f 72 6c 64    == world

	r := []rune(hello)

	fmt.Printf(&quot;UFT-8 encoding of each rune: %x\n&quot;, r) // UFT-8 encoding of each rune: [60a8 597d 20 77 6f 72 6c 64]

	// 60a8 597d      == 您好
	// 20             == &lt;white space character&gt;
	// 77 6f 72 6c 64 == world

	fmt.Println(len(hello)) // 12

	// Looks like 'hello' stores 8 characters, but the 2 chinese characters represent more than 2 bytes each
	// Instead we'd need to count the Runes...

	fmt.Println(utf8.RuneCountInString(hello)) // 8
	
	// The DecodeRuneInString method also returns the number of bytes each Rune occupies...
	
	rune1, size := utf8.DecodeRuneInString(&quot;您&quot;)
	fmt.Printf(&quot;Rune: %v\nRune's Byte Size: %v\n&quot;, rune1, size) 
	
	// Rune: 24744
	// Rune's Byte Size: 3
	
	rune2, size := utf8.DecodeRuneInString(&quot;好&quot;)
	fmt.Printf(&quot;Rune: %v\nRune's Byte Size: %v\n&quot;, rune2, size) 
	
	// Rune: 22909 (type: int32)
	// Rune's Byte Size: 3
	
	// Type conversion from a integer to a string yields not a stringified number but the UTF-8 representation of that Rune...
	
	fmt.Println(string(rune1))  // 您
	fmt.Println(string(rune2))  // 好
	fmt.Println(string(r))      // 您好 world
	fmt.Println(string(65))     // A

	// Use 0x prefix to denote a UTF-8 encoding...
	
	fmt.Println(string(0x60a8)) // 您
	fmt.Println(string(0x597d)) // 好
}
</code></pre>

<h2 id="code-examples">Code Examples</h2>

<h3 id="init">Init</h3>

<p>When you load a package in Go, only the public functions and variables are exposed for the caller to utilise. So if you need a package to execute some bootstrapping code at the point of it being <em>loaded</em>, then you&rsquo;ll need to stick it inside of an <code>init</code> function.</p>

<blockquote>
<p>Note: you can have multiple <code>init</code> functions inside a package
e.g. one per file within the package namespace</p>
</blockquote>

<p>But be careful with race conditions!</p>

<p>I&rsquo;ve hit an issue where we had:</p>

<ul>
<li><code>main.go</code>

<ul>
<li><code>foo.go</code> (loaded by <code>main.go</code>)

<ul>
<li><code>bar.go</code> (loaded by <code>foo.go</code>)</li>
</ul></li>
</ul></li>
</ul>

<p>Each one of these packages had its own <code>init</code> function and ultimately the <code>bar.go</code>&rsquo;s <code>init</code> function was being run first, followed by the <code>foo.go</code>&rsquo;s <code>init</code> function and finally followed by the <code>main.go</code>&rsquo;s <code>init</code> function.</p>

<p>The reason this was an issue was because <code>main.go</code> was loading some environment variables needed by <code>bar.go</code> but those variables weren&rsquo;t available by the time the <code>bar.go</code> was running (as that happened <em>before</em> <code>main.go</code>&rsquo;s <code>init</code> function had executed.</p>

<p>The solution was to rename all the <code>init</code> functions to <code>Init</code> and explicitly call them to bootstrap the package when needed (i.e. they didn&rsquo;t automatically bootstrap themselves and find themselves in a race condition)</p>

<h3 id="new-vs-make">New vs Make</h3>

<ul>
<li><code>func new(Type) *Type</code>: allocate memory for custom-user type</li>
<li><code>func make(Type, size IntegerType) Type</code>: allocate memory for builtin types (Slice, Map, Chan)</li>
</ul>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	foo := make(map[string]string)
	fmt.Println(foo) // map[]
	foo[&quot;k1&quot;] = &quot;bar&quot;
	fmt.Println(foo) // map[k1:bar]
	fmt.Println(foo[&quot;k1&quot;]) // bar
	
	type bar [5]int
	b := new(bar)
	fmt.Println(b) // &amp;[0 0 0 0 0]
	b[0] = 1
	fmt.Println(b) // &amp;[1 0 0 0 0]
}
</code></pre>

<h3 id="custom-types">Custom Types</h3>

<pre><code class="language-go">package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

type path []byte // our custom Type

// method attached to our custom Type
func (p *path) TruncateAtFinalSlash() {
	i := bytes.LastIndex(*p, []byte(&quot;/&quot;))

	if i &gt;= 0 {
		*p = (*p)[0:i]
	}
}

func main() {
	pathName := path(&quot;/usr/bin/tso&quot;) // Conversion from string to path.

	pathName.TruncateAtFinalSlash()

	fmt.Printf(&quot;%s\n&quot;, pathName)
}
</code></pre>

<p>Alternative example:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type foo [5]int

func main() {
	f := new(foo)
	fmt.Println(f) // &amp;[0 0 0 0 0]
	f[0] = 1
	fmt.Println(f) // &amp;[1 0 0 0 0]
	f.Bar()
	fmt.Println(f) // &amp;[1 2 0 0 0]

	// We can coerce custom types like we can with built-in types
	b := foo([5]int{9, 9, 9})
	fmt.Println(b) // [9 9 9 0 0]
	
	// Check the types
	fmt.Printf(&quot;%T\n&quot;, b)               // main.foo
	fmt.Printf(&quot;%T\n&quot;, [5]int{9, 9, 9}) // [5]int
}

func (f *foo) Bar() {
	f[1] = 2
}
</code></pre>

<h3 id="function-types">Function Types</h3>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Foo func(int, string)

func (f Foo) Bar(s string) {
	fmt.Printf(&quot;s: %s\n&quot;, s)
}

func FooIt(x int, y string) {
	fmt.Printf(&quot;x: %d - y: %s\n&quot;, x, y)
}

// We HAVE to define the incoming type of &quot;fn&quot;
// Which in this case is a Foo type
func TestIt(fn Foo) {
	fn(99, &quot;problems&quot;)
}

// We could do this without defining a func type
// But as you can see, this is a bit ugly
// Plus if we need this function passed around a lot
// then it means a lot of duplicated effort 
// typing the signature over and over
func TestItManually(fn func(int, string)) {
	fn(100, &quot;problems&quot;)
}

func main() {
	// Here we're just demonstrating passing around the FooIt function
	// It demonstrates first-class function support in Go
	// But also that we can ensure the function passed around has the expected signature
	TestIt(FooIt)
	TestItManually(FooIt)
	
	x := Foo(FooIt) // Convert our function into a Foo type
	x(0, &quot;hai&quot;)     // Now we can execute it as we would FooIt itself
	
	FooIt(1, &quot;bye&quot;)
	
	// Notice the types are different
	// FooIt is just a function with a signature (no known type associated with it)
	// Where as &quot;x&quot; is of known type &quot;Foo&quot;
	fmt.Printf(&quot;%T\n&quot;, FooIt) // func(int, string)
	fmt.Printf(&quot;%T\n&quot;, x)     // main.Foo
	
	// But we'll see that the function &quot;x&quot; 
	// which was converted into a Foo type
	// now has access to a Bar method
	// Although FooIt has a matching signature, it's not a Foo type
	// and so it doesn't have a Bar method available
	x.Bar(&quot;we have a Bar method&quot;)
	
	// We can't even execute:
	// FooIt.Bar(&quot;we don't have a Bar method&quot;)
	// Because the compiler will stop us
}
</code></pre>

<h3 id="struct-var-vs-type">Struct: Var vs Type</h3>

<p>A variable of Struct type doesn&rsquo;t need to be instantiated like a type struct:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

var data struct {
	A string
	B string
}

type data2 struct {
	A string
	B string
}

func main() {
	data.A = &quot;Hai&quot;
	data.B = &quot;Bai&quot;
	
	fmt.Printf(
		&quot;%#v, %+v, %+v&quot;, 
		data.A, 
		data.B, 
		data2{A: &quot;abc&quot;, B: &quot;def&quot;}
	)
	// &quot;Hai&quot;, Bai, {A:abc B:def}
}
</code></pre>

<p>### Reference vs Value</p>

<p>Map data structures are passed by reference, rather than a copied value</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	m := make(map[string]int)
	fmt.Println(&quot;main before, m = &quot;, m)
	foo(m)
	fmt.Println(&quot;main after, m = &quot;, m)
}

func foo(m map[string]int) {
	fmt.Println(&quot;foo before, m = &quot;, m)
	m[&quot;hai&quot;] = 123
	fmt.Println(&quot;foo after, m = &quot;, m)
}
</code></pre>

<p>In fact, anything with <code>make</code> is a reference, as well as any explicit interface</p>

<h3 id="see-all-methods-of-a-lt-type-gt">See all methods of a &amp;lt;Type&amp;gt;</h3>

<pre><code class="language-go">errType := reflect.TypeOf(err)
for i := 0; i &lt; errType.NumMethod(); i++ {
  method := errType.Method(i)
  fmt.Println(method.Name)
}
</code></pre>

<h3 id="set-time">Set time</h3>

<pre><code class="language-go">now := time.Now()
fmt.Println(now)
expiration := now.Add(time.Hour * 24 * 30)
fmt.Println(&quot;Thirty days from now will be : &quot;, expiration)
</code></pre>

<h3 id="convert-struct-into-json">Convert Struct into JSON</h3>

<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;time&quot;
)

func main() {
	type Message struct {
		Sequence  int    `json:&quot;sequence&quot;`
		Title     string `json:&quot;title&quot;`
		Timestamp time.Time   `json:&quot;timestamp&quot;`
	}
	msg := Message{1, &quot;Foobar&quot;, time.Now()}
	b, err := json.Marshal(msg)
	if err != nil {
		fmt.Println(&quot;error:&quot;, err)
	}
	os.Stdout.Write(b)
}
</code></pre>

<h3 id="extract-only-json-you-need">Extract only JSON you need</h3>

<p><a href="https://medium.com/the-hoard/using-golang-and-json-for-kafka-consumption-with-high-throughput-4cae28e08f90#.7rcmae71b" target="_blank">https://medium.com/the-hoard/using-golang-and-json-for-kafka-consumption-with-high-throughput-4cae28e08f90#.7rcmae71b</a></p>

<p>Effectively the solution is:</p>

<pre><code class="language-go">/*
imagine our variable 'bytes' contains some JSON with lots of fields
we only want the fields 'type' and 'id' 
we should get our provider of data to transform everything else inside a 'data' field

e.g.

{
  “id”: “numero uno”,
  “type”: “transaction”,
  // data is the JSON msg from above
  “data”: { 
    “id”: “numero uno”,
    “type”: “transaction”,
    // … a whole bunch of dynamic fields
    “amount”: “1000”,
    “currency”: “usd”,
    // … etc.
   }
}
*/

type Message struct {
  ID string `json:”id”`
  Type string `json:”type”`
  Data json.RawMessage `json:”data”`
}

var m Message
json.Unmarshal(bytes, &amp;m)
es.Index(index, m.Type, m.ID, &quot;&quot;, &quot;&quot;, nil, m.Data, false)
</code></pre>

<p>This way we only decode the id and type, so we&rsquo;re being performant, and then we pass the original raw JSON onto our next service (e.g. <code>es</code> ElasticSearch) to do with what they please.</p>

<h3 id="nested-json-handling">Nested JSON handling</h3>

<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
)

type Component struct {
	Components []struct {
		Id  string `json:&quot;id&quot;`
		Url string `json:&quot;url&quot;`
	} `json:&quot;components&quot;`
}

func main() {
	var c Component

	b := []byte(`{&quot;components&quot;:[{&quot;id&quot;:&quot;google&quot;,&quot;url&quot;:&quot;http://google.com/&quot;},{&quot;id&quot;:&quot;integralist&quot;,&quot;url&quot;:&quot;http://integralist.co.uk/&quot;},{&quot;id&quot;:&quot;sloooow&quot;,&quot;url&quot;:&quot;http://stevesouders.com/cuzillion/?c0=hj1hfff5_0_f&amp;c1=hc1hfff2_0_f&amp;t=1439190969678&quot;}]}`)

	json.Unmarshal(b, &amp;c)
	
	fmt.Printf(&quot;%+v&quot;, c.Components[0]) // {Id:google Url:http://google.com/}
}
</code></pre>

<h3 id="pretty-printing-json-string">Pretty Printing JSON String</h3>

<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	type ColorGroup struct {
		ID     int
		Name   string
		Colors []string
	}
	group := ColorGroup{
		ID:     1,
		Name:   &quot;Reds&quot;,
		Colors: []string{&quot;Crimson&quot;, &quot;Red&quot;, &quot;Ruby&quot;, &quot;Maroon&quot;},
	}
	b, err := json.MarshalIndent(group, &quot;&quot;, &quot;    &quot;)
	if err != nil {
		fmt.Println(&quot;error:&quot;, err)
	}
	os.Stdout.Write(b)
}
</code></pre>

<h3 id="nested-yaml-handling">Nested YAML handling</h3>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;gopkg.in/yaml.v2&quot;
)

type ComponentYaml struct {
	Id  string `yaml:&quot;id&quot;`
	Url string `yaml:&quot;url&quot;`
}

type ComponentsYamlList struct {
	Components []ComponentYaml `yaml:&quot;components&quot;`
}

func main() {
	var y ComponentsYamlList

	yaml.Unmarshal([]byte(&quot;components:\n  - id: google\n    url: http://google.com\n  - id: integralist\n    url: http://integralist.co.uk&quot;), &amp;y)

	fmt.Println(y)
}
</code></pre>

<h3 id="unknown-yaml-structure">Unknown YAML Structure</h3>

<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;os&quot;

	&quot;gopkg.in/yaml.v2&quot;
)

var yml = []byte(`
- key: foo
  value: bar
  secret: false
- key: beep
  value: boop
  secret: true
`)

type Data struct {
	Items []map[string]interface{}
}

func main() {
	y := []map[string]interface{}{}

	if err := yaml.Unmarshal(yml, &amp;y); err == nil {
		fmt.Printf(&quot;%#v\n&quot;, y)
	} else {
		fmt.Println(err.Error())
	}

	myYaml := Data{Items: y}

	json.NewEncoder(os.Stdout).Encode(myYaml.Items)
}
</code></pre>

<h3 id="sorting-structs">Sorting Structs</h3>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

type vals []Value

type Value struct {
	Key string
	Value string
	Secure bool
}

// Satisfy the Sort interface
func (v vals) Len() int      { return len(v) }
func (v vals) Swap(i, j int) { v[i], v[j] = v[j], v[i] }
func (v vals) Less(i, j int) bool { 
	return v[i].Key &lt; v[j].Key 
}

func main() {
	orig := vals{
		{&quot;CK&quot;, &quot;BV&quot;, false},
		{&quot;DK&quot;, &quot;AV&quot;, true},
		{&quot;AK&quot;, &quot;CV&quot;, false},
		{&quot;BK&quot;, &quot;DV&quot;, true},
	}
	
	fmt.Printf(&quot;%+v\n\n&quot;, orig)
	sort.Sort(orig)
	fmt.Printf(&quot;%+v\n\n&quot;, orig)
}
</code></pre>

<p>Here is a similar version that sorts by name and age:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

type person struct {
	Name string
	Age  int
}

type byName []person

func (p byName) Len() int {
	return len(p)
}
func (p byName) Less(i, j int) bool {
	return p[i].Name &lt; p[j].Name
}
func (p byName) Swap(i, j int) {
	p[i], p[j] = p[j], p[i]
}

type byAge []person

func (p byAge) Len() int {
	return len(p)
}
func (p byAge) Less(i, j int) bool {
	return p[i].Age &lt; p[j].Age
}
func (p byAge) Swap(i, j int) {
	p[i], p[j] = p[j], p[i]
}

func main() {
	kids := []person{
		{&quot;Jill&quot;, 9},
		{&quot;Jack&quot;, 10},
	}

	sort.Sort(byName(kids))
	fmt.Println(kids)

	sort.Sort(byAge(kids))
	fmt.Println(kids)
}
</code></pre>

<p>Which results in:</p>

<pre><code>[{Jack 10} {Jill 9}]
[{Jill 9} {Jack 10}]
</code></pre>

<h3 id="read-users-input">Read Users Input</h3>

<pre><code class="language-go">reader := bufio.NewReader(os.Stdin)
fmt.Print(&quot;Enter text: &quot;)
text, _ := reader.ReadString('\n')
fmt.Println(text)
</code></pre>

<h3 id="web-server">Web Server</h3>

<p>The Go web server design relies on a struct to map routes (URLs) to functions.</p>

<p>You can define your own struct (prefilled for example) and pass it into <code>ListenAndServe</code>. But typically <code>nil</code> is used, which means an empty struct is used by default.</p>

<p>At this point most people will use either <code>HandleFunc</code> or <code>Handle</code> to register their specified request path so it maps to a specific handler function (this is added to the default struct called <code>DefaultServeMux</code>):</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;Hi there, I love %s!&quot;, r.URL.Path[1:])
}

func main() {
    http.HandleFunc(&quot;/&quot;, handler)
    http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>

<p>There is a difference between <code>HandleFunc</code> and <code>Handle</code>. The latter takes a type that has a <code>ServeHTTP</code> method associated to it (we&rsquo;ll see an example in a moment of what this looks like). The former is an abstraction layer that allows an incompatible function (one that doesn&rsquo;t have a <code>ServeHTTP</code> method) to be used as a handler.</p>

<p>The way <code>HandleFunc</code> works is that it wraps the provided function in a call to <code>HandlerFunc</code> (see below for example). In this example <code>HandlerFunc</code> is a type of <code>func</code>, and this type defines the expected function signature and return value(s).</p>

<p>What it states is that a compatible function should have the following signature: <code>ResponseWriter, *Request</code>, and it also attaches the method <code>ServeHTTP</code> to the type <code>HandlerFunc</code>.</p>

<p>Now we can understand that when <code>HandleFunc</code> is called and passed our arbitrary function, we call the <code>HandlerFunc</code> func type and pass it our function, subsequently <em>converting</em> the incoming function so it is now of the type <code>HandlerFunc</code> and will now have gained a <code>ServeHTTP</code> function which allows it to satisfy the <code>Handle</code> interface.</p>

<p>Finally, our <code>HandleFunc</code> - once finished adpating the incoming user function - will internally call the <code>Handle</code> function and pass it the adapted function, which now satisfies the interface required by <code>Handle</code>.</p>

<p>The actual implementation looks like the following (I&rsquo;ve cobbled together all the separate pieces, it doesn&rsquo;t necessarily appear like this in the source code):</p>

<pre><code class="language-go">// We define an interface that states
// if the object has a ServeHTTP method
// then it satisfies this interface
type Handler interface {
  ServeHTTP(ResponseWriter, *Request)
}

// The func type works a bit like an interface
// So if your own user-defined function has a matching signature
// then your function is considered a `HandlerFunc` and will acquire a `ServeHTTP` method
// See directly below for where ServeHTTP is attached to this func type
type HandlerFunc func(ResponseWriter, *Request)

// Once the provided function is converted to the HandlerFunc type
// it'll mean it has the `ServeHTTP` function available
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}

// This is the abstraction function our client code calls...
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    // Here is where we &quot;adapt&quot; the incoming function so it is given a ServeHTTP method
    // We do this by passing it to the HandlerFunc func type
    mux.Handle(pattern, HandlerFunc(handler))
}

// Finally, this is the function that's passed our &quot;adapted/converted&quot; handler function
// The 'handler' passed in now fulfills the 'Handler' interface that says it needs a 'ServeHTTP' method
func (mux *ServeMux) Handle(pattern string, handler Handler) {
    ...do all the things...
}
</code></pre>

<p>This allows the arbitrary function to be used for handling the requested URL.</p>

<p>Below is an example for using <code>handle</code> instead of <code>handleFunc</code>:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

type String string

func (s String) ServeHTTP(
	w http.ResponseWriter,
	r *http.Request) {
	fmt.Fprint(w, s)
}

type Struct struct {
	Greeting string
	Punct    string
	Who      string
}

func (s Struct) ServeHTTP(
	w http.ResponseWriter,
	r *http.Request) {
	fmt.Fprint(w, s.Greeting, s.Punct, s.Who)
}

func main() {
	http.Handle(&quot;/string&quot;, String(&quot;I'm a frayed knot.&quot;))
	http.Handle(&quot;/struct&quot;, &amp;Struct{&quot;Hello&quot;, &quot;:&quot;, &quot;Gophers!&quot;})
	http.ListenAndServe(&quot;localhost:4000&quot;, nil)
}
</code></pre>

<p>Now visit <code>http://localhost:4000/string</code> and <code>http://localhost:4000/struct</code> to see the appropriate output</p>

<h3 id="middleware">Middleware</h3>

<p>This code was modified from <a href="https://medium.com/@matryer/writing-middleware-in-golang-and-how-go-makes-it-so-much-fun-4375c1246e81" target="_blank">https://medium.com/@matryer/writing-middleware-in-golang-and-how-go-makes-it-so-much-fun-4375c1246e81</a></p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;net/http&quot;
	&quot;os&quot;
)

type data struct {
	Greeting string
	Punct    string
	Who      string
}

func (s data) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, s.Greeting, s.Punct, s.Who)
}

type adapter func(http.Handler) http.Handler

func adapt(h http.Handler, adapters ...adapter) http.Handler {
	// Ideally you'd do this in reverse
	// to ensure the order of the middleware
	// matches their specified order
	for _, adapter := range adapters {
		h = adapter(h)
	}
	return h
}

func notify(logger *log.Logger) adapter {
	return func(h http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			logger.Println(&quot;before&quot;)
			defer logger.Println(&quot;after&quot;)
			h.ServeHTTP(w, r)
		})
	}
}

func doSomething() adapter {
	return func(h http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			fmt.Println(&quot;before&quot;)
			defer fmt.Println(&quot;after&quot;)
			h.ServeHTTP(w, r)
		})
	}
}

func main() {
	http.Handle(&quot;/hello&quot;, &amp;data{&quot;Hello&quot;, &quot; &quot;, &quot;Gophers!&quot;})

	logger := log.New(os.Stdout, &quot;server: &quot;, log.Lshortfile)

	http.Handle(&quot;/hello-with-middleware&quot;, adapt(
		&amp;data{&quot;Hello&quot;, &quot; &quot;, &quot;Gophers!&quot;},
		notify(logger), // runs second
		doSomething(), // runs first
	))

	http.ListenAndServe(&quot;localhost:4000&quot;, nil)
}
</code></pre>

<p>This code will run a web server with two valid endpoints:</p>

<ol>
<li><code>/hello</code></li>
<li><code>/hello-with-middleware</code></li>
</ol>

<p>The client sees the same output but the latter endpoint produces the following stdout output:</p>

<pre><code>before
server: middleware.go:35: before
server: middleware.go:38: after
after
</code></pre>

<h3 id="sessions">Sessions</h3>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
	&quot;time&quot;
)

const cookiePrefix = &quot;integralist-example-cookie-&quot;

func main() {
	http.HandleFunc(&quot;/&quot;, login)
	http.HandleFunc(&quot;/admin&quot;, admin)
	http.HandleFunc(&quot;/logout&quot;, logout)
	http.ListenAndServe(&quot;localhost:4000&quot;, nil)
}

func login(w http.ResponseWriter, r *http.Request) {
	if r.Method == &quot;GET&quot; {
		fmt.Fprintf(w, `
&lt;html&gt;
  &lt;body&gt;
    &lt;form method=&quot;POST&quot;&gt;
      Username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
      &lt;br /&gt;
      Password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
      &lt;br /&gt;
      &lt;input type=&quot;submit&quot; value=&quot;Login&quot;&gt;
  &lt;/body&gt;
&lt;/html&gt;
`)
	}

	if r.Method == &quot;POST&quot; {
		username := r.FormValue(&quot;username&quot;)
		password := r.FormValue(&quot;password&quot;)

		if username == &quot;admin&quot; &amp;&amp; password == &quot;password&quot; {
			http.SetCookie(w, &amp;http.Cookie{
				Name:  cookiePrefix + &quot;user&quot;,
				Value: username,
			})
			http.Redirect(w, r, &quot;/admin&quot;, 302)
		} else {
			fmt.Fprintf(w, `
&lt;html&gt;
  &lt;body&gt;
		Login details were incorrect. Sorry, &lt;a href=&quot;/&quot;&gt;try again&lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;
`)
		}
	}
}

func logout(w http.ResponseWriter, r *http.Request) {
	http.SetCookie(w, &amp;http.Cookie{
		Name:    cookiePrefix + &quot;user&quot;,
		Value:   &quot;&quot;,
		Expires: time.Now(),
	})

	http.Redirect(w, r, &quot;/&quot;, 302)
}

func admin(w http.ResponseWriter, r *http.Request) {
	cookie, err := r.Cookie(cookiePrefix + &quot;user&quot;)
	if err != nil {
		http.Redirect(w, r, &quot;/&quot;, 401) // Unauthorized
		return
	}

	fmt.Fprintf(w, `
&lt;html&gt;
  &lt;body&gt;
	  Logged into admin area as: %s&lt;br&gt;&lt;br&gt;
		&lt;a href=&quot;/logout&quot;&gt;Logout&lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;
`, cookie.Value)
}
</code></pre>

<h3 id="http-requests-with-timeouts">HTTP Requests with Timeouts</h3>

<pre><code class="language-go">// Wait for 1.5 release to be able to verify timeout error (bug in language)
// Use -race flag https://blog.golang.org/race-detector to detect race conditions

package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;sync&quot;
	&quot;time&quot;

	&quot;gopkg.in/yaml.v2&quot;
)

type ComponentYaml struct {
	Id  string `yaml:&quot;id&quot;`
	Url string `yaml:&quot;url&quot;`
}

type Component struct {
	Id  string `json:&quot;id&quot;`
	Url string `json:&quot;url&quot;`
}

type ComponentsYamlList struct {
	Components []ComponentYaml `yaml:&quot;components&quot;`
}

type ComponentsList struct {
	Components []Component `json:&quot;components&quot;`
}

type ComponentResponse struct {
	Id     string
	Status int
	Body   string
}

type Result struct {
	Status     string
	Components []ComponentResponse
}

var overallStatus string = &quot;success&quot;

func getComponents() []byte {
	return []byte(`{&quot;components&quot;:[{&quot;id&quot;:&quot;local&quot;,&quot;url&quot;:&quot;http://localhost:8080/pugs&quot;},{&quot;id&quot;:&quot;google&quot;,&quot;url&quot;:&quot;http://google.com/&quot;},{&quot;id&quot;:&quot;integralist&quot;,&quot;url&quot;:&quot;http://integralist.co.uk/&quot;},{&quot;id&quot;:&quot;sloooow&quot;,&quot;url&quot;:&quot;http://stevesouders.com/cuzillion/?c0=hj1hfff30_5_f&amp;t=1439194716962&quot;}]}`)
}

func getComponent(wg *sync.WaitGroup, client *http.Client, i int, v Component, ch chan ComponentResponse) {
	defer wg.Done()

	resp, err := client.Get(v.Url)

	if err != nil {
		fmt.Printf(&quot;Problem getting the response: %s\n\n&quot;, err)

		ch &lt;- ComponentResponse{
			v.Id, 500, err.Error(),
		}
	} else {
		defer resp.Body.Close()
		contents, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			fmt.Printf(&quot;Problem reading the body for %s -&gt; %s\n&quot;, v.Id, err)
		}

		ch &lt;- ComponentResponse{
			v.Id, resp.StatusCode, string(contents),
		}
	}
}

func main() {
	var cr []ComponentResponse
	var c ComponentsList
	var y ComponentsYamlList

	ch := make(chan ComponentResponse)
	b := getComponents() // to be read from a file

	yaml.Unmarshal([]byte(&quot;components:\n  - id: google\n    url: http://google.com\n  - id: integralist\n    url: http://integralist.co.uk&quot;), &amp;y)
	json.Unmarshal(b, &amp;c)

	timeout := time.Duration(1 * time.Second)
	client := http.Client{
		Timeout: timeout,
	}

	var wg sync.WaitGroup
	for i, v := range c.Components {
		wg.Add(1)
		go getComponent(&amp;wg, &amp;client, i, v, ch)
		cr = append(cr, &lt;-ch)
	}
	wg.Wait()

	j, err := json.Marshal(Result{overallStatus, cr})
	if err != nil {
		fmt.Printf(&quot;Problem converting to JSON: %s\n&quot;, err)
		return
	}

	fmt.Println(string(j))
	fmt.Println(y)
}
</code></pre>

<h3 id="s3-getobject">S3 GetObject</h3>

<pre><code class="language-go">import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;

	&quot;github.com/BBC-News/mozart-config-api/src/logger&quot;
	&quot;github.com/aws/aws-sdk-go/aws&quot;
	&quot;github.com/aws/aws-sdk-go/aws/awserr&quot;
	&quot;github.com/aws/aws-sdk-go/service/s3&quot;
)

func HandleStatusRequest(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, &quot;ok&quot;)
}

func HandleGetRequest(w http.ResponseWriter, r *http.Request) {
	svc := s3.New(&amp;aws.Config{
		Region:           aws.String(&quot;eu-west-1&quot;),
		Endpoint:         aws.String(&quot;s3.spurious.localhost:32769&quot;),
		DisableSSL:       aws.Bool(true),
		S3ForcePathStyle: aws.Bool(true),
	})

	params := &amp;s3.GetObjectInput{
		Bucket: aws.String(&quot;int-mozart-config-api&quot;),
		Key:    aws.String(&quot;/v1/int/news/foo.json&quot;),
	}

	resp, err := svc.GetObject(params)

	// ABSTRACT INTO A FUNCTION IN A NAMESPACE!
	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(&quot;1. &quot;, awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(&quot;2. &quot;, reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			fmt.Println(&quot;3. &quot;, err.Error())
		}
	}

	data, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		fmt.Println(&quot;Error reading content&quot;, err)
	}

	fmt.Println(data) // =&gt; []byte
	fmt.Println(string(data[:]))

	w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
	w.Write(data)
	logger.Metric(&quot;200 response&quot;)
}
</code></pre>

<h3 id="compile-time-variables">Compile time variables</h3>

<pre><code class="language-go">var (
    Version   string
    BuildTime string
)
</code></pre>

<p>Now build the project using:</p>

<pre><code class="language-bash">go build -ldflags &quot;-X github.com/&lt;user&gt;/&lt;project&gt;/core.Version=1.0.0 -X github.com/&lt;user&gt;/&lt;project&gt;/core.BuildTime=2015-10-03T11:08:49+0200&quot; main.go
</code></pre>

<h3 id="tls-http-request">TLS HTTP Request</h3>

<pre><code class="language-go">package requester

import (
	&quot;crypto/tls&quot;
	&quot;crypto/x509&quot;
	&quot;flag&quot;
	&quot;io/ioutil&quot;
	&quot;log&quot;
	&quot;net/http&quot;
)

var (
	certFile = flag.String(&quot;cert&quot;, &quot;/etc/pki/tls/certs/client.crt&quot;, &quot;A PEM eoncoded certificate file.&quot;)
	keyFile  = flag.String(&quot;key&quot;, &quot;/etc/pki/tls/private/client.key&quot;, &quot;A PEM encoded private key file.&quot;)
	caFile   = flag.String(&quot;CA&quot;, &quot;/etc/ca/cloud-ca.pem&quot;, &quot;A PEM eoncoded CA's certificate file.&quot;)
)

func SecureClient() *http.Client {
	// Load client cert
	cert, err := tls.LoadX509KeyPair(*certFile, *keyFile)
	if err != nil {
		log.Fatal(err)
	}

	// Load CA cert
	caCert, err := ioutil.ReadFile(*caFile)
	if err != nil {
		log.Fatal(err)
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	// Setup HTTPS client
	tlsConfig := &amp;tls.Config{
		Certificates:       []tls.Certificate{cert},
		RootCAs:            caCertPool,
		InsecureSkipVerify: true,
	}
	tlsConfig.BuildNameToCertificate()
	transport := &amp;http.Transport{TLSClientConfig: tlsConfig}
	client := &amp;http.Client{Transport: transport}

	return client
}
</code></pre>

<p>And to use it&hellip;</p>

<pre><code class="language-go">client := requester.SecureClient()

// GET
resp, err := client.Get(someEndpoint)

// POST
req, err := http.NewRequest(&quot;POST&quot;, someEndpoint, bytes.NewBuffer(jsonStr))
req.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
resp, err := client.Do(req)
</code></pre>

<h3 id="custom-http-request">Custom HTTP Request</h3>

<p>Go doesn&rsquo;t provide abstractions for all the various HTTP request types, so for things like <code>PUT</code> you have to implement it yourself. The following is an example that creates a secure (TLS/HTTPS) <code>PUT</code> abstraction&hellip;</p>

<pre><code class="language-go">func SecurePut(url, contentType string, configFile io.Reader) (*http.Response, error) {
	client := &amp;http.Client{Transport: configureTLS()}
	req, err := http.NewRequest(&quot;PUT&quot;, url, configFile)
	if err != nil {
		return nil, err
	}
	req.Header.Add(&quot;Content-Type&quot;, contentType)
	resp, err := client.Do(req)

	return resp, err
}

func configureTLS() *http.Transport {
	certFilePath := &quot;path/to/cert&quot;
	keyFilePath := &quot;path/to/privateKey&quot;
	caPath := &quot;path/to/ca&quot;

	// Load client cert
	cert, err := tls.LoadX509KeyPair(certFilePath, keyFilePath)
	if err != nil {
		msg := fmt.Sprintf(&quot;Error loading developer cert, path: \&quot;%s\&quot;&quot;, certFilePath)
		output.Error(msg)
	}

	// Load CA cert
	caCert, err := ioutil.ReadFile(caPath)
	if err != nil {
		msg := fmt.Sprintf(&quot;Error loading CA cert, path: \&quot;%s\&quot;&quot;, caPath)
		output.Error(msg)
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	// Setup HTTPS client
	tlsConfig := &amp;tls.Config{
		Certificates:       []tls.Certificate{cert},
		RootCAs:            caCertPool,
		InsecureSkipVerify: true,
	}
	tlsConfig.BuildNameToCertificate()

	return &amp;http.Transport{TLSClientConfig: tlsConfig}
}
</code></pre>

<h3 id="http-get-web-page">HTTP GET Web Page</h3>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;os&quot;
)

func main() {
	response, err := http.Get(&quot;http://www.integralist.co.uk/&quot;)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	defer response.Body.Close()

	contents, err := ioutil.ReadAll(response.Body)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	fmt.Println(string(contents))
}
</code></pre>

<h3 id="pointers">Pointers</h3>

<pre><code class="language-go">package main

import &quot;fmt&quot;

// Point stores co-ordinates
type Point struct {
	x int
	y int
}

// If receiver (Point) isn't set to a pointer (*Point) 
// then the struct's field value won't be updated outside the method
func (p *Point) scaleBy(factor int) {
	fmt.Printf(&quot;scaleBy (before modification): %+v\n&quot;, p)

	// Don't need to derefence (*) struct fields
	// Compiler will perform an implicit &amp;p for you
	// You only need to dereference in standard functions when a argument pointer is required (see below Array Pointer example)
	p.x *= factor
	p.y *= factor

	fmt.Printf(&quot;scaleBy (after modification): %+v\n&quot;, p)
}

func main() {
	// Doesn't matter if we do or don't get the address space (&amp;) for foo/bar's Point
	foo := &amp;Point{1, 2}
	bar := &amp;Point{6, 8}

	fmt.Printf(&quot;Main foo.x: %+v\n&quot;, foo.x)
	fmt.Printf(&quot;Main bar.x: %+v\n&quot;, bar.x)

	foo.scaleBy(5)
	bar.scaleBy(5)

	fmt.Printf(&quot;Main foo.x: %+v\n&quot;, foo.x)
	fmt.Printf(&quot;Main foo.y: %+v\n&quot;, foo.y)

	fmt.Printf(&quot;Main bar.x: %+v\n&quot;, bar.x)
	fmt.Printf(&quot;Main bar.y: %+v\n&quot;, bar.y)
}
</code></pre>

<blockquote>
<p>Note: compiler can only apply implicit dereference for variables and struct fields<br />
this wouldn&rsquo;t work <code>Point{1, 2}.scaleBy(5)</code></p>
</blockquote>

<p>Results in the following output:</p>

<pre><code>Main foo.x: 1
Main bar.x: 6
scaleBy (before modification): &amp;{x:1 y:2}
scaleBy (after modification): &amp;{x:5 y:10}
scaleBy (before modification): &amp;{x:6 y:8}
scaleBy (after modification): &amp;{x:30 y:40}
Main foo.x: 5
Main foo.y: 10
Main bar.x: 30
Main bar.y: 40
</code></pre>

<h3 id="array-pointer">Array Pointer</h3>

<p>Deference an Array pointer so you can mutate the original Array values:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {  
    x := [3]int{1,2,3}

    func(arr *[3]int) {
        (*arr)[0] = 7
        fmt.Println(arr) //prints &amp;[7 2 3]
    }(&amp;x)

    fmt.Println(x) //prints [7 2 3]
}
</code></pre>

<p>Alternatively you can utilise a Slice instead of an Array, as the slice &lsquo;header&rsquo; already has a &lsquo;pointer&rsquo; to an underlying Array:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {  
    x := []int{1,2,3}

    func(arr []int) {
        arr[0] = 7
        fmt.Println(arr) //prints [7 2 3]
    }(x)

    fmt.Println(x) //prints [7 2 3]
}
</code></pre>

<h3 id="type-assertion">Type Assertion</h3>

<pre><code class="language-go">if e, ok := err.(net.Error); ok &amp;&amp; e.Timeout() {
	//
}

type argError struct {
    arg  int
    prob string
}

func (e *argError) Error() string {
    return fmt.Sprintf(&quot;%d - %s&quot;, e.arg, e.prob)
}

if ae, ok := e.(*argError); ok {
	//
}
</code></pre>

<h3 id="line-count">Line Count</h3>

<p>Demonstrates how to use <code>bufio</code> package to scan a file and read it line by line, and then how to increment a map integer value using the shortcut <code>map[key]++</code>. Finally, demonstrates nested maps and ranging over them:</p>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	counts := make(map[string]map[string]int)
	files := os.Args[1:]
	if len(files) == 0 {
		countLines(os.Stdin, &quot;n/a&quot;, counts)
	} else {
		for _, arg := range files {
			f, err := os.Open(arg)
			if err != nil {
				fmt.Fprintf(os.Stderr, &quot;dup2: %v\n&quot;, err)
				continue
			}
			countLines(f, arg, counts)
			f.Close()
		}
	}
	for key, nestedMap := range counts {
		fmt.Printf(&quot;Text: %s\n&quot;, key)
		for filename, count := range nestedMap {
			fmt.Printf(&quot;\tFile: %s\n\tCount: %d\n&quot;, filename, count)
		}
		fmt.Println(&quot;&quot;)
	}
}

func countLines(f *os.File, filename string, counts map[string]map[string]int) {
	input := bufio.NewScanner(f)
	for input.Scan() {
		if val, ok := counts[input.Text()]; ok {
			val[filename]++
		} else {
			inner := make(map[string]int)
			inner[filename]++
			counts[input.Text()] = inner
		}
	}
}
</code></pre>

<h3 id="measuring-time">Measuring time</h3>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

// Sleep requires a Duration
// time has set of constants we can use (lowest is 1 Duration)
// Second constant is an abstraction over the other constants
func main() {
	start := time.Now()
	time.Sleep(time.Duration(5) * time.Second) // sleep 5 seconds
	secs := time.Since(start).Seconds()

	fmt.Printf(&quot;Time spent: %f seconds&quot;, secs)
}
</code></pre>

<h3 id="reading-a-file-in-chunks">Reading a file in chunks</h3>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;os&quot;
)

func main() {
	// Create file (truncates file if it already exists)
	file, err := os.Create(&quot;created.txt&quot;)
	if err != nil {
		log.Fatal(err)
	}

	// Populate byte slice with some content
	b := make([]byte, 0)
	for i := 0; i &lt; 5; i++ {
		b = append(b, '!')
		b = append(b, '\n')
		// notice single quotes for Rune rather than double quote for String
	}
	for i := 0; i &lt; 5; i++ {
		b = append(b, '?')
		b = append(b, '\n')
		// notice single quotes for Rune rather than double quote for String
	}
	for i := 0; i &lt; 5; i++ {
		b = append(b, '%')
		b = append(b, '\n')
		// notice single quotes for Rune rather than double quote for String
	}

	// Write file contents
	bytesWritten, err := file.Write(b)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf(&quot;Bytes written: %+v\n&quot;, bytesWritten)

	// Although getting the bytes written was useful for us
	// in this example, you might need to get total bytes
	// which can be done by copying file contents into dev/null
    // io.Copy(ioutil.Discard, resp.Body)

	// Get current offset
	// 1st arg is how much to seek forward/backwards by
	// 2nd arg is relative to different settings
	// 		0 == relative to start of file
	// 		1 == current offset
	// 		2 == relative to end of file
	currentOffset, err := file.Seek(0, 1)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf(&quot;Current offset: %d\n&quot;, currentOffset)
	file.Seek(-currentOffset, 1) // Return to start of file for next Read

	// Read buffered view of file
	data := make([]byte, 10, bytesWritten) // create slice with underlying Array capacity set to total file bytes size
	eof := false
	for !eof {
		count, err := file.Read(data)
		if err != nil {
			eof = true
		}
		fmt.Printf(&quot;read %d bytes: %q\n&quot;, count, data[:count])
	}
}
</code></pre>

<h3 id="time-and-channels">Time and Channels</h3>

<p>Basic example that pauses execution until the timer has expired (you would use this over a <code>timer.Sleep</code> because you can cancel a timer before it has expired;):</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	timer := time.NewTimer(time.Second * 2)

	&lt;-timer.C // pauses for two seconds

	fmt.Println(&quot;Timer expired&quot;)
}
</code></pre>

<p>Example of cancelling the timer:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	timer := time.NewTimer(time.Second * 2)

	// Expensive process run in a separate thread
	go func() {
		&lt;-timer.C
		fmt.Println(&quot;Timer expired&quot;)
	}()

	stop := timer.Stop() // cancel the timer
	fmt.Println(stop)    // true
}
</code></pre>

<p>We can do a similar thing with Timers:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	ticker := time.NewTicker(time.Millisecond * 500)

	// Repetitive process
	go func() {
		// Range over the channel rather than pull from it
		for t := range ticker.C {
			fmt.Println(&quot;Tick:&quot;, t)
		}
	}()

	// Stop ticker after three ticks/intervals
	time.Sleep(time.Millisecond * 1500)
	ticker.Stop()
}
</code></pre>

<p>We can combine all these items together with a <code>select</code> statement like so:</p>

<pre><code class="language-go">package main

import &quot;time&quot;
import &quot;fmt&quot;

func main() {
	timeChan := time.NewTimer(time.Second).C
	tickChan := time.NewTicker(time.Millisecond * 400).C

	// Used to signify we're done with this program
	doneChan := make(chan bool)

	// Sleep for two seconds, then notify the channel we're done
	go func() {
		time.Sleep(time.Second * 2)
		doneChan &lt;- true
	}()

	for {
		select {
		case &lt;-timeChan:
			fmt.Println(&quot;Timer expired&quot;)
		case &lt;-tickChan:
			fmt.Println(&quot;Ticker ticked&quot;)
		case &lt;-doneChan:
			fmt.Println(&quot;Done&quot;)
			return
		}
	}
}
</code></pre>

<p>The output of this program would be something like:</p>

<pre><code>Ticker ticked
Ticker ticked
Timer expired
Ticker ticked
Ticker ticked
Done
</code></pre>

<h3 id="quit-a-channel">Quit a Channel</h3>

<p>I would imagine that for most cases you&rsquo;ll want to use a <code>time.NewTimer</code> as seen in previous examples if you want to stop a goroutine that&rsquo;s processing a long running program. The following example is more for stopping a goroutine that&rsquo;s running code at a set interval (although using <code>time.NewTicker</code> would probably be more appropriate):</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	quit := make(chan bool)

	// Run a piece of code at a set interval
	go func() {
		for {
			select {
			case &lt;-quit:
				return
			default:
				fmt.Println(&quot;Not ready to stop this goroutine&quot;)
				time.Sleep(time.Millisecond * 100)
			}
		}
	}()

	// Do other stuff for two seconds
	time.Sleep(time.Second * 2)

	// Quit goroutine
	quit &lt;- true

	fmt.Println(&quot;Goroutine was stopped&quot;)
}
</code></pre>

<h3 id="starting-and-stopping-things-with-channels">Starting and Stopping things with Channels</h3>

<p>Starting a goroutine:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	// Use a struct type channel as it clarifies your intent
	// Which is this channel is used for 'signalling'
	start := make(chan struct{})

	for i := 0; i &lt; 10000; i++ {
		go func() {
			&lt;-start // wait for the start channel to be closed
			fmt.Println(&quot;do stuff&quot;)
		}()
	}

	// at this point, all goroutines are ready to go
	// we just need to tell them to start by
	// closing the start channel
	close(start)

	fmt.Println(&quot;Let's pause briefly to give goroutines time to execute&quot;)

	time.Sleep(time.Millisecond * 10)
}
</code></pre>

<p>Stopping a goroutine:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	// Use a struct type channel as it clarifies your intent
	// Which is this channel is used for 'signalling'
	done := make(chan struct{})

	// Long running process put onto a thread
	go func() {
		fmt.Println(&quot;Inside thread doing expensive processing&quot;)
		time.Sleep(time.Second * 5)
		close(done)
	}()

	fmt.Println(&quot;Do other things&quot;)

	// Wait for long running process to finish
	&lt;-done

	fmt.Println(&quot;Do more things&quot;)
}
</code></pre>

<h3 id="channel-pipelines">Channel Pipelines</h3>

<p>The principle of a pipeline, is to take data from one function and pass it into another function, that receiving function will process the received data and then that result is returned and subsequently passed onto another function&hellip; rinse and repeat for however long your pipeline needs to be.</p>

<p>In the below example (copied from <a href="https://blog.gopheracademy.com/advent-2015/automi-stream-processing-over-go-channels/" target="_blank">here</a>) demonstrates how a set of functions accept a channel and return a channel and so channels is the &lsquo;data&rsquo; that is passed around the pipeline functions:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;
import &quot;sync&quot;

func ingest() &lt;-chan []string {
	out := make(chan []string)
	go func() {
		out &lt;- []string{&quot;aaaa&quot;, &quot;bbb&quot;}
		out &lt;- []string{&quot;cccccc&quot;, &quot;dddddd&quot;}
		out &lt;- []string{&quot;e&quot;, &quot;fffff&quot;, &quot;g&quot;}
		close(out)
	}()
	return out
}

func process(concurrency int, in &lt;-chan []string) &lt;-chan int {
	var wg sync.WaitGroup
	wg.Add(concurrency)

	out := make(chan int)

	work := func() {
		for data := range in {
			for _, word := range data {
				out &lt;- len(word)
			}
		}
		wg.Done()

	}

	go func() {
		for i := 0; i &lt; concurrency; i++ {
			go work()
		}

	}()

	go func() {
		wg.Wait()
		close(out)
	}()
	return out
}

func store(in &lt;-chan int) &lt;-chan struct{} {
	done := make(chan struct{})
	go func() {
		defer close(done)
		for data := range in {
			fmt.Println(data)
		}
	}()
	return done
}

func main() {
	// stage 1 ingest data from source
	in := ingest()

	// stage 2 - process data
	reduced := process(4, in)

	// stage 3 - store
	&lt;-store(reduced)
}
</code></pre>

<h3 id="templating">Templating</h3>

<p>Here is a basic program that uses a Struct for its data source:</p>

<pre><code class="language-go">package main

import (
	&quot;log&quot;
	&quot;os&quot;
	&quot;text/template&quot;
)

type dataSource struct {
	Baz int
}

func (ds dataSource) Foo() string {
	return &quot;I am foo&quot;
}

func (ds dataSource) Bar() string {
	return &quot;I am bar&quot;
}

const templ = `
	Foo: {{.Foo}}
	Piping: {{.Bar | printf &quot;Bar: %s&quot;}}
	Function: {{.Baz | qux}}
`

func qux(baz int) int {
	return baz * 2
}

// template.Must handles parsing errors better
var setupTemplate = template.Must(
	template.New(&quot;whatever&quot;).
		Funcs(template.FuncMap{&quot;qux&quot;: qux}).
		Parse(templ),
)

func main() {
	ds := dataSource{5}

	if err := setupTemplate.Execute(os.Stdout, ds); err != nil {
		log.Fatal(err)
	}
}
</code></pre>

<blockquote>
<p>Note: <code>printf</code> is a built-in function for templating and is functionally equivalent to <code>fmt.Sprintf</code></p>
</blockquote>

<p>Program output:</p>

<pre><code>Foo: I am foo
Piping: Bar: I am bar
Function: 10
</code></pre>

<p>Here is a HTML templating version:</p>

<pre><code class="language-go">package main

import (
	&quot;html/template&quot;
	&quot;log&quot;
	&quot;os&quot;
)

var data struct {
	A string        // untrusted plain text
	B template.HTML // trusted HTML
}

const templ = `&lt;p&gt;A: {{.A}}&lt;/p&gt;&lt;p&gt;B: {{.B}}&lt;/p&gt;`

func main() {
	t := template.Must(template.New(&quot;escape&quot;).Parse(templ))

	data.A = &quot;&lt;b&gt;Hello&lt;/b&gt;&quot;
	data.B = &quot;&lt;b&gt;Hello&lt;/b&gt;&quot;

	if err := t.Execute(os.Stdout, data); err != nil {
		log.Fatal(err)
	}
}
</code></pre>

<p>The output would be:</p>

<pre><code>&lt;p&gt;A: &amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt;&lt;/p&gt;
&lt;p&gt;B: &lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt;
</code></pre>

<h3 id="error-handling-with-context">Error handling with context</h3>

<p>The following code outputs:</p>

<pre><code>This is our custom error with some more context prefixed: oh noes!
</code></pre>

<pre><code class="language-go">package main

import (
	&quot;errors&quot;
	&quot;fmt&quot;
)

type errWithContext struct {
	err error
	msg string
}

func (e errWithContext) Error() string {
	return e.msg + &quot;: &quot; + e.err.Error()
}

func triggerError() (bool, error) {
	return false, errors.New(&quot;oh noes!&quot;)
}

func main() {
	var e *errWithContext

	_, err := triggerError()
	if err != nil {
		e = &amp;errWithContext{
			err,
			&quot;This is our custom error with some more context prefixed&quot;,
		}
	}

	fmt.Print(e.Error())
}
</code></pre>

<h3 id="socket-programming-with-tcp-server">Socket programming with TCP server</h3>

<p>There are two main types of sockets:</p>

<ol>
<li>STREAM sockets (e.g. TCP)</li>
<li>DATAGRAM sockets (e.g. UDP)</li>
</ol>

<blockquote>
<p>Note: a &ldquo;unix domain socket&rdquo; is actually a physical file<br />
it&rsquo;s useful for local (same host) data communication</p>
</blockquote>

<p>The principle steps behind a socket is:</p>

<ul>
<li>Create the socket</li>
<li>Bind the socket to an address (e.g. <code>127.0.0.1:80</code>)</li>
<li>Listen for socket connections</li>
<li>Accept the socket connection</li>
</ul>

<p>There are two main packages in our below example: <code>server.go</code> and <code>client.go</code>.</p>

<p>Run both of them in separate terminals (e.g. <code>go run ...</code>)</p>

<p>Then for the <code>client.go</code> type your message followed by a new line, for example:</p>

<pre><code>Hello World
Message from server: HELLO WORLD
</code></pre>

<p>Whilst in the <code>server.go</code> terminal you should see:</p>

<pre><code>Starting TCP server...
Message Received: Hello World
</code></pre>

<p>The code for this program is as follows:</p>

<p>server.go</p>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;net&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(&quot;Starting TCP server...&quot;)

	// Listen on all network interfaces (e.g. 0.0.0.0)
	// Documentation: godoc net Listener | less
	listener, _ := net.Listen(&quot;tcp&quot;, &quot;:8081&quot;)

	// Accept connection on the port we specified (see above)
	connection, _ := listener.Accept()

	// Handle incoming connections forever
	for {
		// Listen for message to process ending in newline (\n)
		// Note: single quotes needed for type byte (double quotes is a string)
		message, _ := bufio.NewReader(connection).ReadString('\n')

		// Output message received
		fmt.Println(&quot;Message Received:&quot;, string(message))

		// Do something with the message (e.g. uppercase it)
		newmessage := strings.ToUpper(message)

		// Send new string back to client
		connection.Write([]byte(newmessage + &quot;\n&quot;))
	}
}
</code></pre>

<p>client.go</p>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;net&quot;
	&quot;os&quot;
)

func main() {
	// Open socket connection to a locally runnning TCP server
	connection, _ := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8081&quot;)

	// Handle incoming responses
	for {
		// Read the input
		reader := bufio.NewReader(os.Stdin)

		// Message to be sent
		// Note: single quotes needed for type byte (double quotes is a string)
		// Documentation: godoc bufio ReadString | less
		// ReadString reads until the first occurrence of the delimiter \n in the input
		text, _ := reader.ReadString('\n')

		// Send message to open Socket
		fmt.Fprintf(connection, text+&quot;\n&quot;)

		// Listen for response
		// Note: single quotes needed for type byte (double quotes is a string)
		message, _ := bufio.NewReader(connection).ReadString('\n')

		fmt.Println(&quot;Message from server: &quot; + message)
	}
}
</code></pre>

<h3 id="comparing-maps">Comparing maps</h3>

<p>This code demonstrates how to be careful about false positives!</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func equal(x, y map[string]int) bool {
	if len(x) != len(y) {
		// fail fast
		return false
	}

	for k, xv := range x {
		// Verify &quot;missing&quot; key and &quot;present but zero&quot; key value
		if yv, ok := y[k]; !ok || yv != xv {
			return false
		}
		
		/*
		// The following condition would incorrectly return &quot;true&quot; for the below example comparison!
		// This is because the empty value for an int type is a zero, while the actual value of x's key is zero
		if xv != y[k] {
			return false
		}
		*/
	}

	return true
}

func main() {
	fmt.Println(
		equal(map[string]int{&quot;A&quot;: 0}, map[string]int{&quot;B&quot;: 42}),
	)
}
</code></pre>

<h3 id="embedded-structs">Embedded Structs</h3>

<p>The first example demonstrates a &lsquo;named&rsquo; field utilising an embedded Struct:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Point struct {
	X, Y int
}

type Circle struct {
	Center Point // named embeded field
	Radius int
}

type Wheel struct {
	Circle Circle // named embeded field
	Spokes int
}

func main() {
	var w Wheel
	w.Circle.Center.X = 8
	w.Circle.Center.Y = 8
	w.Circle.Radius = 5
	w.Spokes = 20

	fmt.Printf(&quot;%+v&quot;, w)
}
</code></pre>

<p>Which prints:</p>

<pre><code>{Circle:{Center:{X:8 Y:8} Radius:5} Spokes:20}
</code></pre>

<p>The second example demonstrates an &lsquo;anonymous&rsquo; field instead:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Point struct {
	X, Y int
}

type Circle struct {
	Point
	Radius int
}

type Wheel struct {
	Circle
	Spokes int
}

func main() {
	var w Wheel
	w.X = 8       // w.Circle.Point.X
	w.Y = 8       // w.Circle.Point.Y
	w.Radius = 5  // w.Circle.Radius
	w.Spokes = 20

	fmt.Printf(&quot;%+v&quot;, w)
}
</code></pre>

<p>Which prints:</p>

<pre><code>{Circle:{Point:{X:8 Y:8} Radius:5} Spokes:20}
</code></pre>

<blockquote>
<p>Note: anonymous fields don&rsquo;t work shorthand literal Struct</p>
</blockquote>

<p>The following example demonstrates how methods of a composited object can be accessed from the consuming object:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Point struct {
	X, Y int
}

func (p Point) foo() {
	fmt.Printf(&quot;foo: %+v\n&quot;, p)
}

type Circle struct {
	Point
	Radius int
}

type Wheel struct {
	Circle
	Spokes int
}

func main() {
	var w Wheel
	w.X = 8      // w.Circle.Point.X
	w.Y = 8      // w.Circle.Point.Y
	w.foo()      // w.Circle.Point.foo()
	w.Radius = 5 // w.Circle.Radius
	w.Spokes = 20

	fmt.Printf(&quot;%+v&quot;, w)
}
</code></pre>

<p>Which prints:</p>

<pre><code>foo: {X:8 Y:8}
{Circle:{Point:{X:8 Y:8} Radius:5} Spokes:20}
</code></pre>

<p>Here is a more practical example that demonstrates how embedded functionality can make code more expressive:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
)

// Anonymous struct
var cache = struct {
	sync.Mutex
	mapping map[string]string
}{
	mapping: make(map[string]string), // initial zero value for map
}

func setValue() {
	cache.Lock()
	cache.mapping[&quot;foo&quot;] = &quot;bar&quot;
	cache.Unlock()
}

func main() {
	setValue()

	cache.Lock()
	v := cache.mapping[&quot;foo&quot;]
	cache.Unlock()

	fmt.Printf(&quot;v: %s&quot;, v)
}
</code></pre>

<h3 id="zip-file-contents">Zip File Contents</h3>

<pre><code class="language-go">package main

import (
	&quot;compress/zlib&quot;
	&quot;io&quot;
	&quot;log&quot;
	&quot;os&quot;
)

func main() {
	var err error

	// This defends against an error preventing `defer` from being called
	// As log.Fatal otherwise calls `os.Exit`
	defer func() {
		if err != nil {
			log.Fatalln(&quot;\nDeferred log: \n&quot;, err)
		}
	}()

	src, err := os.Create(&quot;source.txt&quot;)
	if err != nil {
		return
	}
	src.WriteString(&quot;source content&quot;)
	src.Close()

	dest, err := os.Create(&quot;new.txt&quot;)
	if err != nil {
		return
	}

	openSrc, err := os.Open(&quot;source.txt&quot;)
	if err != nil {
		return
	}

	zdest := zlib.NewWriter(dest)
	if _, err := io.Copy(zdest, openSrc); err != nil {
		return
	}

	// Close these explicitly
	zdest.Close()
	dest.Close()

	n, err := os.Open(&quot;new.txt&quot;)
	if err != nil {
		return
	}

	r, err := zlib.NewReader(n)
	if err != nil {
		return
	}
	defer r.Close()
	io.Copy(os.Stdout, r)

	err = os.Remove(&quot;source.txt&quot;)
	if err != nil {
		return
	}

	err = os.Remove(&quot;new.txt&quot;)
	if err != nil {
		return
	}
}
</code></pre>

<h3 id="rpc">RPC</h3>

<p>For details of what RPC means, see: <a href="https://gist.github.com/Integralist/f5856b94e002bcfd4ce7" target="_blank">https://gist.github.com/Integralist/f5856b94e002bcfd4ce7</a></p>

<p>Only methods that satisfy these criteria will be made available for remote access; other methods will be ignored:</p>

<ul>
<li>the method&rsquo;s type is exported.</li>
<li>the method is exported.</li>
<li>the method has two arguments, both exported (or builtin) types.</li>
<li>the method&rsquo;s second argument is a pointer.</li>
<li>the method has return type error.</li>
</ul>

<p>In effect, the method must look schematically like</p>

<pre><code class="language-go">func (t *T) MethodName(argType T1, replyType *T2) error
</code></pre>

<p>The setup for a simple RPC example is:</p>

<ol>
<li>Create remote package Foo that will consist of functions to be made available via RPC</li>
<li>Create remote package that will expose package Foo</li>
<li>Create client package that connects to remote via RPC</li>
</ol>

<p>There are two variations:</p>

<ol>
<li>RPC over HTTP</li>
<li>RPC over TCP</li>
</ol>

<h4 id="http">HTTP</h4>

<p>So here is the package that consists of functions to be made available via RPC:</p>

<pre><code class="language-go">package remote

import &quot;fmt&quot;

// Args is a data structure for the incoming arguments
type Args struct {
	A, B int
}

// Arith is our functions return type
type Arith int

// Multiply does simply multiplication on provided arguments
func (t *Arith) Multiply(args *Args, reply *int) error {
	fmt.Printf(&quot;Args received: %+v\n&quot;, args)
	*reply = args.A * args.B
	return nil
}
</code></pre>

<p>Here is the remote package that exposes the other package of functionality:</p>

<pre><code class="language-go">package main

import (
	&quot;log&quot;
	&quot;net&quot;
	&quot;net/rpc&quot;

	&quot;github.com/integralist/rpc/remote&quot;
)

func main() {
	arith := new(remote.Arith)

	rpc.Register(arith)
	rpc.HandleHTTP()

	l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
	if e != nil {
		log.Fatal(&quot;listen error:&quot;, e)
	}

	rpc.Accept(l)
}
</code></pre>

<p>Here is our client code for connecting to our remote package via RPC:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;net&quot;
	&quot;net/rpc&quot;
	&quot;time&quot;
)

type args struct {
	A, B int
}

func main() {
	conn, err := net.DialTimeout(&quot;tcp&quot;, &quot;localhost:1234&quot;, time.Minute)
	if err != nil {
		log.Fatal(&quot;dialing:&quot;, err)
	}

	client := rpc.NewClient(conn)

	var reply int

	e := client.Call(&quot;Arith.Multiply&quot;, &amp;args{4, 2}, &amp;reply)
	if e != nil {
		log.Fatalf(&quot;Something went wrong: %s&quot;, err.Error())
	}

	fmt.Printf(&quot;The reply pointer value has been changed to: %d&quot;, reply)
}
</code></pre>

<h4 id="tcp">TCP</h4>

<p>Remote RPC Function:</p>

<pre><code class="language-go">package remote

import &quot;fmt&quot;

// Compose is our RPC functions return type
type Compose string

// Details is our exposed RPC function
func (c *Compose) Details(arg string, reply *string) error {
	fmt.Printf(&quot;Arg received: %+v\n&quot;, arg)
	*c = &quot;some value&quot;
	*reply = &quot;Blah!&quot;
	return nil
}
</code></pre>

<p>Remote RPC Endpoint Exposed:</p>

<pre><code class="language-go">package remote

import (
	&quot;fmt&quot;
	&quot;net&quot;
	&quot;net/rpc&quot;

	&quot;github.com/bbc/mozart-api-common/logger&quot;
)

// Endpoint exposes our RPC over TCP service
func Endpoint() {
	compose := new(Compose)

	rpc.Register(compose)
	// rpc.HandleHTTP()

	listener, err := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;)
	if err != nil {
		logMessage := map[string]interface{}{
			&quot;event&quot;:   &quot;FailedTCPListenerConnection&quot;,
			&quot;message&quot;: fmt.Sprintf(&quot;Listener failed to open TCP port 8080: %v&quot;, err),
		}
		logger.Error(logMessage)
	}

	// rpc.Accept(listener)
	for {
		conn, err := listener.Accept()
		if err != nil {
			logMessage := map[string]interface{}{
				&quot;event&quot;:   &quot;FailedTPCIncomingConnection&quot;,
				&quot;message&quot;: fmt.Sprintf(&quot;Listener failed to accept an incoming connection: %v&quot;, err),
			}
			logger.Error(logMessage)
		}

		go rpc.ServeConn(conn)
	}
}
</code></pre>

<p>Client Connection over TCP to Remote RPC function:</p>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;net/rpc&quot;
)

func main() {
	client, err := rpc.Dial(&quot;tcp&quot;, &quot;localhost:8080&quot;)
	if err != nil {
		log.Fatal(&quot;dialing:&quot;, err)
	}

	var reply string

	e := client.Call(&quot;Compose.Details&quot;, &quot;my string&quot;, &amp;reply)
	if e != nil {
		log.Fatalf(&quot;Something went wrong: %v&quot;, e.Error())
	}

	fmt.Printf(&quot;The 'reply' pointer value has been changed to: %s&quot;, reply)
}
</code></pre>

<h4 id="json-rpc">JSON RPC</h4>

<p>There is another option (which is required if using another programming language to communicate with your Go RPC service), that is to turn your RPC into a JSON RPC.</p>

<blockquote>
<p>This is because the standard net/rpc uses <a href="https://golang.org/pkg/encoding/gob/" target="_blank">https://golang.org/pkg/encoding/gob/</a><br />
Which is a Go specific streaming binary format</p>
</blockquote>

<p>Effectively just use the same example as above but make the following changes:</p>

<ul>
<li><code>net/rpc</code> to <code>net/rpc/jsonrpc</code></li>
<li><code>rpc.Dial</code> to <code>jsonrpc.Dial</code></li>
<li><code>rpc.ServeConn</code> to <code>jsonrpc.ServeConn</code></li>
</ul>

<p>Now your clients can connect via a TCP socket and pass over JSON, as shown in Ruby below:</p>

<pre><code class="language-ruby">require &quot;socket&quot;
require &quot;json&quot;

socket = TCPSocket.new &quot;localhost&quot;, &quot;8080&quot;

# Details of JSON structure can be found here:
# https://golang.org/src/net/rpc/jsonrpc/client.go#L45
# Thanks to Albert Hafvenström (@albhaf) for his help
b = {
  :method =&gt; &quot;Compose.Details&quot;,
  :params =&gt; [{ :Foo =&gt; &quot;Foo!&quot;, :Bar =&gt; &quot;Bar!&quot; }],
  :id     =&gt; &quot;0&quot; # id is just echo'ed back to the client
}

socket.write(JSON.dump(b))

p JSON.load(socket.readline)

# =&gt; {&quot;id&quot;=&gt;&quot;0&quot;, &quot;result&quot;=&gt;&quot;Blah!&quot;, &quot;error&quot;=&gt;nil}
</code></pre>

<p>Here is an updated Go RPC:</p>

<pre><code class="language-go">package remote

import &quot;fmt&quot;

// Args is structured around the client's provided parameters
// The fields need to be exported too!
type Args struct {
	Foo string
	Bar string
}

// Compose is our RPC functions return type
type Compose string

// Details is our exposed RPC function
func (c *Compose) Details(args *Args, reply *string) error {
	fmt.Printf(&quot;Args received: %+v\n&quot;, args)
	*c = &quot;some value&quot;
	*reply = &quot;Blah!&quot;
	return nil
}
</code></pre>

<h3 id="enumerator-iota">Enumerator IOTA</h3>

<p>Within a constant declaration, the predeclared identifier <code>iota</code> represents successive untyped integer constants. It is reset to 0 whenever the reserved word <code>const</code> appears in the source.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

const (
	foo = iota // 0
	bar
	_ // skip this value
	baz
)

const (
	beep = iota // 0 (reset)
	boop
)

func main() {
	fmt.Println(foo, bar, baz) // 0 1 3
	fmt.Println(beep, boop)    // 0 1
}
</code></pre>

<h3 id="fizzbuzz">FizzBuzz</h3>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	for i := 1; i &lt;= 100; i++ {
		if i%3 == 0 &amp;&amp; i%5 == 0 {
			fmt.Printf(&quot;%d FizzBuzz\n&quot;, i)
		} else if i%3 == 0 {
			fmt.Printf(&quot;%d Fizz\n&quot;, i)
		} else if i%5 == 0 {
			fmt.Printf(&quot;%d Buzz\n&quot;, i)
		} else {
			fmt.Println(i)
		}
	}
}
</code></pre>

<h3 id="execute-shell-command">Execute Shell Command</h3>

<pre><code class="language-go">var (
  cmdOut []byte
  err    error
)
cmdName := &quot;spurious&quot;
cmdArgs := []string{&quot;ports&quot;, &quot;--json&quot;}
if cmdOut, err = exec.Command(cmdName, cmdArgs...).Output(); err != nil {
  fmt.Fprintln(os.Stderr, &quot;There was an error running 'spurious ports --json' command: &quot;, err)
  os.Exit(1)
}
fmt.Println(string(cmdOut))
</code></pre>

<h3 id="new-instance-idiom">New Instance Idiom</h3>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Sqs struct {
	foo string
}

func (s *Sqs) create() {
	fmt.Println(&quot;I'll create stuff&quot;)
}

func NewSqs() *Sqs {
	return &amp;Sqs{&quot;bop&quot;}
}

func main() {
	s := NewSqs()
	fmt.Println(s.foo)
	s.create()
}
</code></pre>

<h3 id="mutating-values">Mutating Values</h3>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type Compose string

func (c *Compose) Details() string {
	*c = &quot;beep boop&quot;
	return fmt.Sprintf(&quot;Here are your details: %v&quot;, *c)
}

func main() {
	var c Compose
	c = &quot;hai&quot;
	fmt.Printf(&quot;c: %+v\n&quot;, c) // c
	fmt.Println(c.Details())
	fmt.Printf(&quot;c: %+v\n&quot;, c) // beep boop
}
</code></pre>

<h3 id="draining-connections">Draining Connections</h3>

<p>When using <code>json.NewDecoder</code>:</p>

<pre><code class="language-go">func main() {
    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
        var u User
        if r.Body == nil {
            http.Error(w, &quot;Please send a request body&quot;, 400)
            return
        }
        err := json.NewDecoder(r.Body).Decode(&amp;u)
        if err != nil {
            http.Error(w, err.Error(), 400)
            return
        }
        fmt.Println(u.Id)
    })
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}
</code></pre>

<p>&hellip;it doesn&rsquo;t read the response Body completely. So when closing the response you might get an error as a stray <code>\n</code> could be present later on. You&rsquo;ll need to drain the response instead:</p>

<pre><code class="language-go">defer func() {
  io.CopyN(ioutil.Discard, r.Body, 512)
  r.Body.Close()
}()
</code></pre>

<blockquote>
<p>Note: <a href="https://github.com/google/go-github/pull/317" target="_blank">https://github.com/google/go-github/pull/317</a></p>
</blockquote>

</div>
</body>
</html>
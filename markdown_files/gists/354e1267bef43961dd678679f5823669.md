# find and replace content across multiple files 

[View original Gist on GitHub](https://gist.github.com/Integralist/354e1267bef43961dd678679f5823669)

**Tags:** #shell #tools

## comby-example.bash

```shell
# https://comby.dev/
# https://comby.dev/docs/syntax-reference
#
# -match-only -stdout to see what matches it found
# -newline-separated -stdout to see what replacements it will write
# -i to modify the files in-place.

COMBY_M="$(cat <<"MATCH"
fmt.Println(:[arguments])
MATCH
)"

COMBY_R="$(cat <<"REWRITE"
fmt.Println(fmt.Sprintf("comby says %s", :[arguments]))
REWRITE
)"

comby "$COMBY_M"  "$COMBY_R" -stats -match-newline-at-toplevel -i
```

## sed-example.bash

```shell
gsed -i 's/metrics.NewWriter(/metrics.NewLegacyWriter(/' **/*.go

# UPDATE: glob/wildcard doesn't appear to work any more, needs to be individual file streams

find . -type f -name *.go -exec gsed -i 's/foo/bar/' {} \;

# You'll need both -e (extended regex support) and -r (allow backreferences like \1 \2 etc) for more complex examples:

find . -type f -name *.go -exec gsed -i -r -e 's/, ErrMissing(.+)/, NewFieldError("\1")/' {} \;
find . -type f -name *.go -exec gsed -i -r -e 's/(github.com\/)fastly(\/customcli\/)/\1integralist\2/' {} \;
```

## vim-example.viml

```viml
:argdo %s/metrics.NewWriter(/metrics.NewLegacyWriter(/ge | update

# If I'm working with a file type (like go) that messes with the quickfix window I'll typically pipe the list of files into Vim with no vimrc set.
```


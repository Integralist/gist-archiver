<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Refactoring Ruby -> not all conditionals can be removed, and those that can can't necessarily use the standard refactoring methods such as "Replace Type Code with Module Extension", "Replace Type Code with Polymorphism" or "Replace Type Code with State/Strategy". The below examples demonstrate this.</title>
<style>
body { font-family: sans-serif; margin: 20px; line-height: 1.6; background-color: #f4f4f4; color: #333; }
.container { max-width: 800px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
pre { background: #f0f0f0; padding: 1em; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.9em;}
h1, h2 { border-bottom: 1px solid #eee; padding-bottom: 0.3em;}
a.back-link { display: inline-block; margin-bottom: 20px; color: #007bff; text-decoration: none; }
a.back-link:hover { text-decoration: underline; }
</style>
</head>
<body>
<div class="container">
<a href="../index.html" class="back-link">&laquo; Back to Index</a>
<h1 id="refactoring-ruby-not-all-conditionals-can-be-removed-and-those-that-can-can-t-necessarily-use-the-standard-refactoring-methods-such-as-replace-type-code-with-module-extension-replace-type-code-with-polymorphism-or-replace-type-code-with-state-strategy-the-below-examples-demonstrate-this">Refactoring Ruby -&gt; not all conditionals can be removed, and those that can can&rsquo;t necessarily use the standard refactoring methods such as &ldquo;Replace Type Code with Module Extension&rdquo;, &ldquo;Replace Type Code with Polymorphism&rdquo; or &ldquo;Replace Type Code with State/Strategy&rdquo;. The below examples demonstrate this.</h1>

<h2 id="bad-design-rb">Bad Design.rb</h2>

<pre><code class="language-ruby">class Foo
  def initialize(a=[], b=[])
    @a = a
    @b = b
  end
  
  def add(item)
    if item.is_a? A
      @a.push item
    else
      @b.push item
    end
  end
end

class A
  def initialize(name=&quot;Unknown&quot;)
    @name = &quot;A: #{name}&quot;
    @time = Time.now
  end
end

class B
  def initialize(name=&quot;Unknown&quot;)
    @name = &quot;B: #{name}&quot;
    @time = Time.now
  end
end

foo = Foo.new
foo.add(A.new)
foo.add(B.new)
</code></pre>

<h2 id="better-design-rb">Better Design.rb</h2>

<pre><code class="language-ruby"># Thanks to @clauswitt for his guidance

class Foo
  def initialize(storage={})
    @storage = storage
  end
  
  def add(item)
    @storage[item.class] = [] unless @storage.has_key?(item.class)
    @storage[item.class] &lt;&lt; item
  end
end

class A
  def initialize(name=&quot;Unknown&quot;)
    @name = &quot;A: #{name}&quot;
    @time = Time.now
  end
end

class B
  def initialize(name=&quot;Unknown&quot;)
    @name = &quot;B: #{name}&quot;
    @time = Time.now
  end
end

foo = Foo.new
foo.add(A.new)
foo.add(B.new)
</code></pre>

<h2 id="dan-scotton-variation-rb">Dan Scotton Variation.rb</h2>

<pre><code class="language-ruby"># - I've assumed you've separated the items into two arrays
#   because you want to select those items at some point later.
#   I've refactored to 'filter' the items on the way out, rather
#   than filtering them on the way in.
# - Also added a :type method rather than class checking.
# - You could even use Set instead of [] here

class Foo
  def initialize(initial_items = [])
    @items = initial_items
  end

  def add(item)
    @items &lt;&lt; item
  end

  def a
    select(:a)
  end

  def b
    select(:b)
  end

  private

  def select(type)
    @items.select { |item| item.type == type }
  end
end

# If you wanted to create more types in the future, say :c, you
# could dynamically generate the accessors?

class A
  def initialize(name=&quot;Unknown&quot;)
    @name = &quot;A: #{name}&quot;
    @time = Time.now
  end
  
  def type
    :a
  end
end

class B
  def initialize(name=&quot;Unknown&quot;)
    @name = &quot;B: #{name}&quot;
    @time = Time.now
  end
  
  def type
    :b
  end
end

foo = Foo.new
foo.add(A.new)
foo.add(B.new)
</code></pre>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>[Vim search multiple lines with line breaks using PCRE_DOTALL mode] ... #silversearcher #ag #ack #grep #PCRE #regex #vim #lookahead #ripgrep</title>
<link rel="stylesheet" type="text/css" href="../../assets/css/styles.css">
</head>
<body>
<div class="container">
<a href="../index.html" class="back-link">&laquo; Back to Index</a>
<h1 id="vim-search-multiple-lines-with-line-breaks-using-pcre-dotall-mode-silversearcher-ag-ack-grep-pcre-regex-vim-lookahead-ripgrep">[Vim search multiple lines with line breaks using PCRE_DOTALL mode] &hellip; #silversearcher #ag #ack #grep #PCRE #regex #vim #lookahead #ripgrep</h1>

<h2 id="ag-with-pcre-dotall-md">Ag with PCRE_DOTALL.md</h2>

<pre><code class="language-markdown">As noted in this thread: https://github.com/ggreer/the_silver_searcher/issues/459#issuecomment-118785490

The trick to get the PCRE engine have `.` to include new lines is to prefix your pattern with 'Perl options' (http://www.pcre.org/original/doc/html/pcrepattern.html#SEC13). 

So to get `PCRE_DOTALL` we need to prefix our regex pattern with `(?s)`.

For example, consider a file `test.txt` with the following content:

</code></pre>

<p>Line 1
Line 2
Line 3</p>

<pre><code>
We can match all three lines using:

```bash
ag '(?s)Line 1.+Line 3' test.txt
</code></pre>

<blockquote>
<p><strong>NOTE:</strong> The above only works on a file, not when data is piped into <code>ag</code>.</p>
</blockquote>

<p>If you want to check for lines not preceded by another line, e.g. you&rsquo;re looking for&hellip;</p>

<pre><code class="language-yaml">name:
  anyOf:
    - ...
</code></pre>

<p>While avoiding:</p>

<pre><code class="language-yaml">name:
  type: object
  anyOf:
    - ...
</code></pre>

<p>Then use a negative lookbehind assertion:</p>

<pre><code>rg --context 2 --pcre2 --regexp '(?&lt;!type: object)anyOf:'
</code></pre>

<h2 id="ingore-any-matches-with-a-lookahead">Ingore any matches with a lookahead</h2>

<p>Imagine you have the following code across multiple files:</p>

<pre><code class="language-go">serviceID, serviceVersion, err := cmd.ServiceDetails(cmd.ServiceDetailsOpts{
	AllowActiveLocked:  true,
	Client:             c.Globals.Client,
	Manifest:           c.manifest,
	Out:                out,
	ServiceVersionFlag: c.serviceVersion,
	VerboseMode:        c.Globals.Flag.Verbose,
})
</code></pre>

<p>You want to find every instance of the function call <code>cmd.ServiceDetails</code> but ignore any that have a <code>ServiceNameFlag</code> field set (which isn&rsquo;t set in the above example).</p>

<p>To achieve this you&rsquo;d use a negative lookahead <code>(?!&lt;pattern&gt;)</code>. The following example uses the Vim ack plugin to search for the function call, then lookahead to make sure we don&rsquo;t find the field, and then keep matching until the end of the function call&hellip;</p>

<pre><code>:Ack! '(?s)cmd\.ServiceDetails\((?!.+?ServiceNameFlag).+?}\)'
</code></pre>

<p>&rdquo;`</p>

</div>
</body>
</html>
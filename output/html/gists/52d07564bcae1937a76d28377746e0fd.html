<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>AWS KMS</title>
<style>
body { font-family: sans-serif; margin: 20px; line-height: 1.6; background-color: #f4f4f4; color: #333; }
.container { max-width: 800px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
pre { background: #f0f0f0; padding: 1em; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.9em;}
h1, h2 { border-bottom: 1px solid #eee; padding-bottom: 0.3em;}
a.back-link { display: inline-block; margin-bottom: 20px; color: #007bff; text-decoration: none; }
a.back-link:hover { text-decoration: underline; }
</style>
</head>
<body>
<div class="container">
<a href="../index.html" class="back-link">&laquo; Back to Index</a>
<h1 id="aws-kms">AWS KMS</h1>

<h2 id="aws-kms-md">AWS KMS.md</h2>

<pre><code class="language-markdown">&gt; Thanks to [Steven Jack](https://twitter.com/stevenjack85) for helping me understand this

The individual parts of AWS KMS are:

- master key
- encryptor key (encrypted and unencrypted forms)
- app's private key

&gt; Note: the &quot;encryptor&quot; is a key used to encrypt our private key

Here is a simple example to demonstrate the workflow:

- Create a master key in KMS (how you do this is up to you: SDK, CLI, Console)
- Locally (via the AWS cli tool or maybe even via a CI) call `GenerateDataKey`
- When making this call: pass the name of the &quot;master key&quot; in KMS to use
- This results in a temp key `B` (in both unencrypted and encrypted form) being provided
- We can now encrypt key `A` using the unencrypted `B` key 
- We can discard both the unencrypted `A` and `B` keys (as we now have encrypted versions)
- We can bake the encrypted keys (`A` and `B`) into our application (as they're encrypted)
- When our app needs to use key `A`, it needs to decrypt it
- Our app uses KMS to decrypt the `B` key
- Our app then uses the resulting unencrypted `B` key to decrypt our `A` encrypted key

---

Further comments from Steven Jack:

Imagine we have a Jenkins CI job that runs every week.  
It has IAM perms to call `GenerateDataKey` for a specific master key. 

Each week it generates a new random hash for the DB password,  
get’s the temp encryption key,  
encrypts it and pushes both the parts needed into a Kubernetes secrets store.

Once that’s done we simply re-deploy the containers, done.

The app has decrypt perms for that master key and on boot  
give the param it has from the secrets store and get back  
the unencrypted key and decrypt its secret, then uses it.
</code></pre>

</div>
</body>
</html>
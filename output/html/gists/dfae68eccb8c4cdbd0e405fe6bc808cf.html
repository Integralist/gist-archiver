<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>[Python CPU and Memory Profiling Tools] #tags: python, profiling, perf</title>
<link rel="stylesheet" type="text/css" href="../../assets/css/styles.css">
</head>
<body>
<div class="container">
<a href="../index.html" class="back-link">&laquo; Back to Index</a>
<h1 id="python-cpu-and-memory-profiling-tools-tags-python-profiling-perf">[Python CPU and Memory Profiling Tools] #tags: python, profiling, perf</h1>

<h2 id="2-basic-decorator-timer-py">2. basic decorator timer.py</h2>

<pre><code class="language-python">&quot;&quot;&quot;This module is for profiling purposes.&quot;&quot;&quot;

from time import time
from pprint import pprint
from functools import wraps


def timefn(fn):
    &quot;&quot;&quot;Simple timer decorator.&quot;&quot;&quot;
    @wraps(fn)
    def measure_time(*args, **kwargs):
        t1 = time()
        result = fn(*args, **kwargs)
        t2 = time()
        print(f&quot;@timefn: {fn.__name__} took {str(t2 - t1)} seconds&quot;)
        return result
    return measure_time


@timefn
def factorize_naive(n):
    &quot;&quot;&quot;
    Naive factorization method.

    Take integer 'n', return list of factors.
    &quot;&quot;&quot;
    if n &lt; 2:
        return []
    factors = []
    p = 2

    while True:
        if n == 1:
            return factors

        r = n % p
        if r == 0:
            factors.append(p)
            n = n / p
        elif p * p &gt;= n:
            factors.append(n)
            return factors
        elif p &gt; 2:
            # Advance in steps of 2 over odd numbers
            p += 2
        else:
            # If p == 2, get to 3
            p += 1

    assert False, &quot;unreachable&quot;


def serial_factorizer(nums):
    &quot;&quot;&quot;Process factorials lots of times.&quot;&quot;&quot;
    return {n: factorize_naive(n) for n in nums}


if __name__ == &quot;__main__&quot;:
    pprint(serial_factorizer([10000, 100, 4450, 8320, 500000]))
</code></pre>

<h2 id="3-timeit-command-line-module-sh">3. timeit command line module.sh</h2>

<pre><code class="language-shell"># python -m timeit -n &lt;average&gt; -r &lt;repetitions&gt; -s &quot;&lt;import your app&gt;&quot; &quot;&lt;code to be run&gt;&quot;
#
# for longer-running functions it can be sensible to specify the number of loops which are averaged (-n 4) and a number of repetitions of the loops (-r 5)

python -m timeit -n 4 -r 5 -s &quot;from pprint import pprint; import app&quot; &quot;pprint(app.serial_factorizer([10000, 100, 4450, 8320, 500000]))&quot;
</code></pre>

<h2 id="4-cprofile-command-line-module-sh">4. cProfile command line module.sh</h2>

<pre><code class="language-shell">python -m cProfile -s cumulative app.py
</code></pre>

<h2 id="5-memory-profiler-sh">5. memory_profiler.sh</h2>

<pre><code class="language-shell">pip install memory_profiler
pip install psutil

# From VM...
mprof run python /app/video_player.py

# From Host...
ulimit -n 1024
siege &lt;url&gt; -c 255 -t 30S
ll | grep mprofile | tail -n 1 | awk '{print $9}' | xargs cat | tail -n 1 # locate latest mprofile_&lt;timestamp&gt;.dat and display its last line

# MEM 36.324219

</code></pre>

<h2 id="0-readme-md">0. README.md</h2>

<pre><code class="language-markdown">It is worth considering the variation in load that you get on a normal computer. 

Many background tasks are running (e.g. Dropbox, backups) that could impact the CPU and disk resources at random.

Tools available:

* `timeit` module: understand behavior of statements and functions
* `cProfile`: understand which functions in your code take the longest to run (high-level only)
* `line_profiler`: profiles your chosen functions on a line-by-line basis (granular)
* `memory_profiler`: chart RAM usage over time on a labelled chart (function level)
* `heapy`: track all of the objects inside Python’s memory (useful for hunting down memory-leaks)
* `perf stat`: understand number of instructions executed on CPU and how efficiently the CPU’s caches are utilized
* CPython: understand Python stack based vm operates (understand why certain coding styles run more slowly than others)

&gt; [Reference article](http://www.marinamele.com/7-tips-to-time-python-scripts-and-control-memory-and-cpu-usage)

### Locating Python Packages

```bash
find / -type d -name &lt;package_name&gt;

# for example, the result could look like...
#
# ./usr/local/lib/python3.6/site-packages/package_name
</code></pre>

<pre><code>
## 1. app-source.py

```python
&quot;&quot;&quot;This module is for profiling purposes.&quot;&quot;&quot;

from pprint import pprint


def factorize_naive(n):
    &quot;&quot;&quot;
    Naive factorization method.

    Take integer 'n', return list of factors.
    &quot;&quot;&quot;
    if n &lt; 2:
        return []
    factors = []
    p = 2

    while True:
        if n == 1:
            return factors

        r = n % p
        if r == 0:
            factors.append(p)
            n = n / p
        elif p * p &gt;= n:
            factors.append(n)
            return factors
        elif p &gt; 2:
            # Advance in steps of 2 over odd numbers
            p += 2
        else:
            # If p == 2, get to 3
            p += 1

    assert False, &quot;unreachable&quot;


def serial_factorizer(nums):
    &quot;&quot;&quot;Process factorials lots of times.&quot;&quot;&quot;
    return {n: factorize_naive(n) for n in nums}


if __name__ == &quot;__main__&quot;:
    pprint(serial_factorizer([10000, 100, 4450, 8320, 500000]))

</code></pre>

</div>
</body>
</html>
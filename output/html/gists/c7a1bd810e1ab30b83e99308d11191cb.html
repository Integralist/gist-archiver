<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>[Pagination: offset vs cursor] #pagination #design</title>
<link rel="stylesheet" type="text/css" href="../../assets/css/styles.css">
</head>
<body>
<div class="container">
<a href="../index.html" class="back-link">&laquo; Back to Index</a>
<h1 id="pagination-offset-vs-cursor-pagination-design">[Pagination: offset vs cursor] #pagination #design</h1>

<h2 id="readme-md">README.md</h2>

<pre><code class="language-markdown">## What is pagination?

We use pagination to request specific segments of a dataset from an API (and a database) instead of everything at once.

## Offset-based pagination

The use of offset-based pagination requires passing:

- A limit: the number of records per page
- An offset: the position of the first item of a page

Offsets allow page-specific features, and are simple to implement and use.

&gt; [!WARNING]
&gt; Offsets create database performances issues:
&gt;
&gt;  - Page 1: offset = 0, limit = 100, reads and returns 100 records
&gt;  - Page 2: offset = 100, limit = 100, reads **_200_** records, returns 100 records

</code></pre>

<p>/* First request */</p>

<p>/services?filter[customer_id]=123&amp;page[number]=1&amp;page[size]=500</p>

<p>/* Response */</p>

<p>“data” : [,&hellip;],
“meta”: {
  &ldquo;current_page&rdquo;: 1,
  &ldquo;per_page&rdquo;: 500,
  &ldquo;record_count&rdquo;: 1133,
  &ldquo;total_pages&rdquo;: 3
}</p>

<p>/* Next request */</p>

<p>/services?filter[customer_id]=123&amp;page[number]=2&amp;page[size]=500</p>

<pre><code>
## Cursor-based pagination

The use of cursor-based pagination requires passing:

- A limit: the number of records per page

The response will include:

- A cursor: the identifier of the last item in a page

And subsequent request will pass such cursor:

- Page 1: limit = 100, reads and returns 100 records, with a cursor pointing to item 100 (cursor = ABC*)
- Page 2: limit = 100, cursor = ABC, reads and returns 100 records starting with the next item after ABC, with a cursor pointing to item 200 (cursor = DEF*)

&gt; [!NOTE]
&gt; *example identifiers

</code></pre>

<p>/* First request */
/services?filter[customer_id]=123&amp;limit=500</p>

<p>/* Response */
“data” : [,…],
“meta”: {
  &ldquo;next_cursor&rdquo;: “1tkSVoL9b7VAvdIhad9aH8”,
  &ldquo;limit&rdquo;: 500
}</p>

<p>/* Next request */
/services?filter[customer_id]=123&amp;limit=500&amp;cursor=1tkSVoL9b7VAvdIhad9aH8</p>

<pre><code>
&gt; [!IMPORTANT]
&gt; Cursor-based pagination provides a consistent query time, ideal for vast and changing datasets, and excluding total count and number of pages makes the performance optimization even more significative.

## Issues with cursor-based pagination

- The lack of total number of items in cursor-based responses makes it difficult to provide that information with certainty for clients in one request
- In the case of some UI clients, this removes the ability to provide numbered pages for large datasets, but traversing to previous and next “pages” is still possible.
- It is recommended that you remove page counts as a feature provided in the API responses.
- The total number of items remains a needed feature, for what we recommend a secondary request to obtain that number.
- Lack of page numbers make a strong argument for record discoverability in the UI, an issue we can address with better dataset search capabilities.

</code></pre>

<p>/* Count request */
/services?filter[customer_id]=123&amp;total=true</p>

<p>/* Response */
“data” : [],
“meta”: {
  &ldquo;total&rdquo;: 1113
}</p>

<pre><code></code></pre>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Clojure destructuring using `let` (which allows local storage inside of a function, we would say a local "variable" but that would be misleading because all data is immutable in Clojure)</title>
<style>
body { font-family: sans-serif; margin: 20px; line-height: 1.6; background-color: #f4f4f4; color: #333; }
.container { max-width: 800px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
pre { background: #f0f0f0; padding: 1em; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.9em;}
h1, h2 { border-bottom: 1px solid #eee; padding-bottom: 0.3em;}
a.back-link { display: inline-block; margin-bottom: 20px; color: #007bff; text-decoration: none; }
a.back-link:hover { text-decoration: underline; }
</style>
</head>
<body>
<div class="container">
<a href="../index.html" class="back-link">&laquo; Back to Index</a>
<h1 id="clojure-destructuring-using-let-which-allows-local-storage-inside-of-a-function-we-would-say-a-local-variable-but-that-would-be-misleading-because-all-data-is-immutable-in-clojure">Clojure destructuring using <code>let</code> (which allows local storage inside of a function, we would say a local &ldquo;variable&rdquo; but that would be misleading because all data is immutable in Clojure)</h1>

<h2 id="let-destructuring-md">Let Destructuring.md</h2>

<pre><code class="language-markdown">In Clojure you can apply destructuring within either a `let` binding list; function parameter list or even a macro.

A simple example would be:

```clj
(def coords [5 7]) ; define a symbol &quot;coords&quot; that points to a vector [5 7]
(let [[x y] coords] (println &quot;x:&quot; x &quot;y:&quot; y))
; =&gt; x: 5 y: 7
</code></pre>

<p>Another simple example (this time using the <code>&amp;</code> rest operator) would be:</p>

<pre><code class="language-clj">(def indexes [1 2 3])
(let [[x &amp; more] indexes] (println &quot;x:&quot; x &quot;more:&quot; more))
; =&gt; x: 1 more: (2 3)
</code></pre>

<p>A complex example (which utilises <code>:as e</code> to assign the entire item being destructured into <code>e</code>):</p>

<pre><code class="language-clj">(def indexes [1 2 3 4 5 6 7])
(let [[a b c &amp; d :as e] indexes]
  [a b c d e])
; =&gt; [1 2 3 (4 5 6 7) [1 2 3 4 5 6 7]]
</code></pre>

<p>Although possible to do nested destructuring, it is advised not to nest as it can become too complex:</p>

<pre><code class="language-clj">(def nested [[1 2][3 4]])
(let [[[x1 y1][x2 y2]] nested]
  [x1 x2 y1 y2])
; =&gt; [1 3 2 4]
</code></pre>

<p>Here is an example that uses <code>:or</code> to provide default values for keys that can&rsquo;t be found in the data being destructured (you&rsquo;ll notice that the <code>b</code> key wasn&rsquo;t provided and so we received the default value of <code>22</code> instead):</p>

<pre><code class="language-clj">(def a-map {:a 1 :c 3})
(let [{a :a, b :b, c :c, :as original-data :or {a 11 b 22 c 33}} a-map]
  [a b c original-data])
; =&gt; [1 22 3 {:a 1, :c 3}]
</code></pre>

<p>In the following example we see the use of <code>:keys</code> as a shortcut way of not having to redefine the same keys ourselves (typically when destructuring data you&rsquo;ll end up saying something like &ldquo;give me the value for key &lsquo;a&rsquo; and just put it in this other place called &lsquo;a&rsquo;&rdquo; - so Clojure provides a shortcut for that). This example also demonstrates what happens if no default is provided:</p>

<pre><code class="language-clj">(def a-map {:a 1 :c 3})
(let [{:keys [a b c]} a-map]
  [a b c])
; =&gt; [1 nil 3]
</code></pre>

<p>Nested map destructuring (whatever the type is - in this example a map - use that syntax to delve deeper into the structure):</p>

<pre><code class="language-clj">(def test {:params {:foo &quot;bar&quot; :baz &quot;qux&quot;}})
(let [{{foo :foo} :params} test] 
  (prn foo))
</code></pre>

<p>&rdquo;`</p>

</div>
</body>
</html>
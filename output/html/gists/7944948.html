<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Sandi Metz advice for writing tests</title>
<style>
body { font-family: sans-serif; margin: 20px; line-height: 1.6; background-color: #f4f4f4; color: #333; }
.container { max-width: 800px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
pre { background: #f0f0f0; padding: 1em; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.9em;}
h1, h2 { border-bottom: 1px solid #eee; padding-bottom: 0.3em;}
a.back-link { display: inline-block; margin-bottom: 20px; color: #007bff; text-decoration: none; }
a.back-link:hover { text-decoration: underline; }
</style>
</head>
<body>
<div class="container">
<a href="../index.html" class="back-link">&laquo; Back to Index</a>
<h1 id="sandi-metz-advice-for-writing-tests">Sandi Metz advice for writing tests</h1>

<h2 id="rules-for-good-testing-md">rules for good testing.md</h2>

<pre><code class="language-markdown"># Rules for good testing

Look at the following image...

![](https://speakerd.s3.amazonaws.com/presentations/ac751bc0918e01300e0b6698bdce82b7/slide_29.jpg?1367359730)

...it shows an object being tested. 

You can't see inside the object. All you can do is send it messages. This is an important point to make because we should be &quot;testing the interface, and NOT the implementation&quot; - doing so will allow us to change the implementation without causing our tests to break.

Messages can go 'into' an object and can be sent 'out' from an object (as you can see from the image above, there are messages going in as well as messages going out). That's fine, that's how objects communicate.

Now there are two types of messages: 'query' and 'command'...

## Queries

Queries are messages that &quot;return something&quot; and &quot;change nothing&quot;. 

In programming terms they are &quot;getters&quot; and not &quot;setters&quot;.

## Commands

Commands are messages that &quot;return nothing&quot; and &quot;change something&quot;.

In programming terms they are &quot;setters&quot; and not &quot;getters&quot;.

## What to test?

- Test incoming query messages by making assertions about what they send back
- Test incoming command messages by making assertions about direct public side effects

## What NOT to test?

- Messages that are sent from within the object itself (e.g. private methods).
- Outgoing query messages (as they have no public side effects)
- Outgoing command messages (use mocks and set expectations on behaviour to ensure rest of your code pass without error)
- Incoming messages that have no dependants (just remove those tests)

Note: there is no point in testing outgoing messages because they should be tested as incoming messages on another object

## What to Mock/Stub

Command messages should be mocked, while query messages should be stubbed

## Contract Tests

Contract tests exist to ensure a specific 'role' (or 'interface' by another - stricter - name) actually presents an API that we expect.

These types of tests can be useful to ensure third party APIs do (or don't) cause our code to break when we update the version of the software.

&gt; Note: if the libraries we use follow [Semantic Versioning](http://semver.org/) then this should only happen when we do a major version upgrade. But it's still good to have contract/role/interface tests in place to catch any problems.

The following is a modified example (written in Ruby) borrowed from the book &quot;Practical Object-Oriented Design in Ruby&quot;:

```ruby
# Following test asserts that SomeObject (@some_object) 
# implements the method `some_x_interface_method`
module SomeObjectInterfaceTest
  def test_object_implements_the_x_interface
    assert_respond_to(@some_object, :some_x_interface_method)
  end
end

# Following test proves that Foobar implements the SomeObject role correctly
# i.e. Foobar implements the SomeObject interface
class FoobarTest &lt; MiniTest::Unit::TestCase
  include SomeObjectInterfaceTest

  def setup
    @foobar = @some_object = Foobar.new
  end

  # ...other tests...
end
</code></pre>

<p>&rdquo;`</p>

</div>
</body>
</html>
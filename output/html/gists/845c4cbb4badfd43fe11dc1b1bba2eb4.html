<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>[Golang unzip(.zip) and untar(.tar.gz) contents of archive to specified destination] #go #golang #unzip #chunk #tar #gz</title>
<style>
body { font-family: sans-serif; margin: 20px; line-height: 1.6; background-color: #f4f4f4; color: #333; }
.container { max-width: 800px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
pre { background: #f0f0f0; padding: 1em; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.9em;}
h1, h2 { border-bottom: 1px solid #eee; padding-bottom: 0.3em;}
a.back-link { display: inline-block; margin-bottom: 20px; color: #007bff; text-decoration: none; }
a.back-link:hover { text-decoration: underline; }
</style>
</head>
<body>
<div class="container">
<a href="../index.html" class="back-link">&laquo; Back to Index</a>
<h1 id="golang-unzip-zip-and-untar-tar-gz-contents-of-archive-to-specified-destination-go-golang-unzip-chunk-tar-gz">[Golang unzip(.zip) and untar(.tar.gz) contents of archive to specified destination] #go #golang #unzip #chunk #tar #gz</h1>

<h2 id="golang-untar-contents-of-tar-gz-archive-to-specified-destination-go">Golang untar contents of tar.gz archive to specified destination.go</h2>

<pre><code class="language-go">// untar will decompress a tar.gz archive, moving all files and folders
// within the archive (parameter 1) to an output directory (parameter 2).
func untar(src io.Reader, dst string) error {
	gr, err := gzip.NewReader(src)
	if err != nil {
		return fmt.Errorf(&quot;error creating gzip reader: %w&quot;, err)
	}
	defer gr.Close()

	tr := tar.NewReader(gr)

	for {
		header, err := tr.Next()

		switch {

		// If no more files are found return
		case err == io.EOF:
			return nil

		// Return any other error
		case err != nil:
			return err

		// If the header is nil, skip it
		case header == nil:
			continue

		// Skip the any files duplicated as hidden files
		case strings.HasPrefix(header.Name, &quot;._&quot;):
			continue
		}

		// The target location where the dir/file should be created
		segs := strings.Split(header.Name, string(filepath.Separator))
		segs = segs[1:]
		target := filepath.Join(dst, filepath.Join(segs...))

		fi := header.FileInfo()

		if fi.IsDir() {
			os.MkdirAll(target, os.ModePerm)
			continue
		}

		if err = os.MkdirAll(filepath.Dir(target), os.ModePerm); err != nil {
			return err
		}

		fd, err := os.OpenFile(target, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, fi.Mode())
		if err != nil {
			return err
		}

		// NOTE: We use looped CopyN() not Copy() to avoid gosec G110 (CWE-409):
		// Potential DoS vulnerability via decompression bomb.
		for {
			_, err := io.CopyN(fd, tr, 1024)
			if err != nil {
				if err == io.EOF {
					break
				}
				return err
			}
		}

		fd.Close()
	}
}
</code></pre>

<h2 id="golang-unzip-contents-of-zip-archive-to-specified-destination-go">Golang unzip contents of zip archive to specified destination.go</h2>

<pre><code class="language-go">// unzip will decompress a zip archive, moving all files and folders
// within the zip file (parameter 1) to an output directory (parameter 2).
func unzip(src string, dst string) ([]string, error) {
	var filenames []string

	r, err := zip.OpenReader(src)
	if err != nil {
		return filenames, err
	}
	defer r.Close()

	for _, f := range r.File {
		// The zip contains a folder, and inside that folder are the files we're
		// interested in. So while looping over the files (whose .Name field is the
		// full path including the containing folder) we strip out the first path
		// segment to ensure the files we need are extracted to the current directory.
		segs := strings.Split(f.Name, string(filepath.Separator))
		segs = segs[1:]
		fpath := filepath.Join(dst, filepath.Join(segs...))
		filenames = append(filenames, fpath)

		if f.FileInfo().IsDir() {
			os.MkdirAll(fpath, os.ModePerm)
			continue
		}

		if err = os.MkdirAll(filepath.Dir(fpath), os.ModePerm); err != nil {
			return filenames, err
		}

		fd, err := os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
		if err != nil {
			return filenames, err
		}

		rc, err := f.Open()
		if err != nil {
			return filenames, err
		}

		// NOTE: We use looped CopyN() not Copy() to avoid gosec G110 (CWE-409):
		// Potential DoS vulnerability via decompression bomb.
		for {
			_, err := io.CopyN(fd, rc, 1024)
			if err != nil {
				if err == io.EOF {
					break
				}
				return filenames, err
			}
		}

		fd.Close()
		rc.Close()

		if err != nil {
			return filenames, err
		}
	}

	return filenames, nil
}
</code></pre>

</div>
</body>
</html>
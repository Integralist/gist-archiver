<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Design Patterns: Adapter vs Facade vs Bridge</title>
<style>
body { font-family: sans-serif; margin: 20px; line-height: 1.6; background-color: #f4f4f4; color: #333; }
.container { max-width: 800px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
pre { background: #f0f0f0; padding: 1em; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.9em;}
h1, h2 { border-bottom: 1px solid #eee; padding-bottom: 0.3em;}
a.back-link { display: inline-block; margin-bottom: 20px; color: #007bff; text-decoration: none; }
a.back-link:hover { text-decoration: underline; }
</style>
</head>
<body>
<div class="container">
<a href="../index.html" class="back-link">&laquo; Back to Index</a>
<h1 id="design-patterns-adapter-vs-facade-vs-bridge">Design Patterns: Adapter vs Facade vs Bridge</h1>

<h2 id="design-patterns-adapter-vs-facade-vs-bridge-md">Design Patterns: Adapter vs Facade vs Bridge.md</h2>

<pre><code class="language-markdown">The three design patterns (Adapter, Facade and Bridge) all produce the result of a clean public API. The difference between the patterns are usually due to a subtle context shift (and in some cases, a behavioural requirement).

## Adapter

The primary function of an Adapter is to produce a *unified* interface for a number of underlying and unrelated objects.

You will notice this pattern being utilised in many applications. For example, ActiveRecord (the popular Ruby ORM; object-relational mapping) creates a unified interface as part of its API but the code underneath the interface is able to communicate with many different types of databases. Allowing the consumer of the API to not have to worry about specific database implementation details.

The principle structure of this pattern is:

</code></pre>

<h2 id="current-future">Current | Future</h2>

<p>B&copy;    | B(A)</p>

<pre><code>
The `B` function cannot be changed and it is dependant on the interface that was originally provided by `C`, but now we are passing in `A` which has an incompatible interface.

An adapter can solve this by creating a new function `A2C` which contains the relevant logic for handling the interaction between `B` and `A`.

</code></pre>

<h2 id="current-future-1">Current | Future</h2>

<p>B&copy;    | B(A2C(A))</p>

<pre><code>
## Facade

The primary function of a Facade is to simplify the interaction between a consumer and an interface.

Most DSL's are a facade of some form. The popular jQuery library consists of multiple facades (one for each type of feature). For example, the jQuery `ajax` method makes it very easy to make an XHR (`XMLHttpRequest`).

&gt; The difference between a Facade and an Adapter is that the Facade makes a simple abstraction, where as an Adapter will handle complex interactions by taking incoming data and constructing it to work with the underlying objects.

## Bridge

The primary function of a Bridge is to decouple an abstraction from its implementation.

&gt; Adapter makes things work _after_ they're designed  
&gt; Bridge makes them work _before_ they are

Imagine you have a function that abstracts the implementation detail of making an HTTP request to an external API endpoint. In a language like JavaScript you might tightly couple the abstraction with the consumer code.

For example:

```js
function get(e) {
  return asyncRequest('foo?bar=' + this.id, function(response) {
    console.log(response)
  })
}

myTrigger.addEventListener('click', get, false)
</code></pre>

<p>The above abstraction (i.e. the <code>get</code> function) will only ever work within the context of a web browser. The abstraction has been tightly coupled to the consumer.</p>

<p>Utilising a bridge will allow us to decouple this code:</p>

<pre><code class="language-js">function get(id, callback) {
  return asyncRequest('foo?bar=' + id, function(response) {
    callback(response)
  })
}

function getBridge(e) {
  get(this.id, function(response) {
    console.log(response)
  })
}

myTrigger.addEventListener('click', getBridge, false)
</code></pre>

<p>&rdquo;`</p>

</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>[Golang Pointers - Guidelines] #go #golang #pointers #guidelines</title>
<style>
body { font-family: sans-serif; margin: 20px; line-height: 1.6; background-color: #f4f4f4; color: #333; }
.container { max-width: 800px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
pre { background: #f0f0f0; padding: 1em; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.9em;}
h1, h2 { border-bottom: 1px solid #eee; padding-bottom: 0.3em;}
a.back-link { display: inline-block; margin-bottom: 20px; color: #007bff; text-decoration: none; }
a.back-link:hover { text-decoration: underline; }
</style>
</head>
<body>
<div class="container">
<a href="../index.html" class="back-link">&laquo; Back to Index</a>
<h1 id="golang-pointers-guidelines-go-golang-pointers-guidelines">[Golang Pointers - Guidelines] #go #golang #pointers #guidelines</h1>

<h2 id="golang-pointers-guidelines-md">Golang Pointers - Guidelines.md</h2>

<pre><code class="language-markdown">## Reference

Information was pulled from https://medium.com/@kent.rancourt/go-pointers-when-to-use-pointers-4f29256ddff3

## Problems with Pointers

- nil dereferencing.
- accidental mutation.

&gt; an unrelated comment would be, from a code design perspective, functions should not dip inside of data structures to access nested fields (I've seen this done to access a pointer to a struct): [law of demeter](https://en.wikipedia.org/wiki/Law_of_Demeter).

1. Avoid pointers (you can always justify your way into using them later if necessary).
2. Don't expect pointers to be more efficient: benchmark! (pass-by-value 'copies' are placed in the 'stack' not 'heap' and thus are handled faster by the CPU).
3. When returning a pointer, also return a bool to indicate success (in case of error, returning an empty struct will cause a nil dereference error for caller if they don't expect an empty struct).
4. Use a pointer when a function needs to modify its receiver (e.g. create method on struct whose receiver is a pointer, that way user can pass around/work with a non-pointer and when calling the method will the compiler switch to a pointer receiver to allow data modification).
5. Use a pointer when you need a singleton.

## Best Practice for Singleton

For components with great importance, we should control the terms on which others interact with them. To do this, create an exported interface with a non-exported implementation, where pointers to the component in question implement the interface.

```go
package main

import (
	&quot;fmt&quot;
)

type S struct {
	// ...
}

type Cache interface {
	Add(key string, val S)
	Get(key string)
	Clear()
}

type cache struct {
	foo string
	bar int
}

func NewCache() Cache { // &lt;--- This is what the caller sees
	return &amp;cache{&quot;beep&quot;, 456} // &lt;--- It's a pointer, but they don't need to know
}

func (c *cache) Add(key string, val S) {
	// ...
}

func (c *cache) Get(key string) {
	// ...
}

func (c *cache) Clear() {
	// ...
}

func main() {
	c := NewCache()
	fmt.Printf(&quot;%+v\n&quot;, c) // &lt;--- caller can see the structure &amp;{foo:beep bar:456}
	fmt.Printf(&quot;%+v\n&quot;, c.foo) // &lt;--- but they can't interact with it (compile time error: c.foo undefined (type Cache has no field or method foo))
}
</code></pre>

<p>&rdquo;`</p>

</div>
</body>
</html>